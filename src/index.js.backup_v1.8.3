import { Router } from 'itty-router';

const router = Router();

// ============================================
// HELPERS & UTILITIES
// ============================================

function generateToken() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

function corsHeaders() {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, X-API-Key',
  };
}

// ============================================
// AUTHENTICATION MIDDLEWARE
// ============================================

async function authenticateRequest(request, env) {
  const apiKey = request.headers.get('X-API-Key');
  
  if (!apiKey) {
    return new Response(JSON.stringify({ error: 'API Key required' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const tenant = await env.DB.prepare(
    'SELECT * FROM tenants WHERE api_key = ?'
  ).bind(apiKey).first();

  if (!tenant) {
    return new Response(JSON.stringify({ error: 'Invalid API Key' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  return tenant;
}

// ============================================
// NOTIFICATION HELPERS
// ============================================

async function sendAppointmentNotifications(env, appointmentId, managementToken, firstName, datetime, phone, email) {
  const localDate = new Date(datetime).toLocaleDateString('fr-FR', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  
  const formattedTime = `${new Date(datetime).getHours()}h${new Date(datetime).getMinutes().toString().padStart(2, '0')}`;
  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  // SMS
  if (phone && env.TWILIO_ACCOUNT_SID && env.TWILIO_AUTH_TOKEN) {
    try {
      const smsBody = `Bonjour ${firstName}, RDV confirmé le ${localDate} à ${formattedTime}. Gérer: ${managementUrl}`;
      
      const twilioResponse = await fetch(
        `https://api.twilio.com/2010-04-01/Accounts/${env.TWILIO_ACCOUNT_SID}/Messages.json`,
        {
          method: 'POST',
          headers: {
            'Authorization': 'Basic ' + btoa(`${env.TWILIO_ACCOUNT_SID}:${env.TWILIO_AUTH_TOKEN}`),
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            To: phone,
            From: env.TWILIO_PHONE_NUMBER,
            Body: smsBody
          })
        }
      );

      if (twilioResponse.ok) {
        const twilioData = await twilioResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `).bind(
          `notif_${Date.now()}_sms`,
          appointmentId,
          'sms',
          phone,
          'sent',
          twilioData.sid,
          new Date().toISOString()
        ).run();
      }
    } catch (error) {
      console.error('Erreur SMS:', error);
    }
  }

  // EMAIL
  if (email && email !== 'noemail@placeholder.com' && env.RESEND_API_KEY) {
    try {
      const emailResponse = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${env.RESEND_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          from: env.RESEND_FROM_EMAIL,
          to: [email],
          subject: `Rendez-vous confirmé - ${localDate}`,
          html: `
            <h2>Bonjour ${firstName},</h2>
            <p>Votre rendez-vous est confirmé :</p>
            <ul>
              <li><strong>Date :</strong> ${localDate}</li>
              <li><strong>Heure :</strong> ${formattedTime}</li>
            </ul>
            <p><a href="${managementUrl}">Gérer mon rendez-vous</a></p>
          `,
        })
      });

      if (emailResponse.ok) {
        const emailData = await emailResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `).bind(
          `notif_${Date.now()}_email`,
          appointmentId,
          'email',
          email,
          'sent',
          emailData.id,
          new Date().toISOString()
        ).run();
      }
    } catch (error) {
      console.error('Erreur Email:', error);
    }
  }
}

// ============================================
// VAPI LOGGING HELPER
// ============================================

async function logVapiCall(env, data) {
  const logId = `log_${Date.now()}`;
  const now = new Date().toISOString();
  
  await env.DB.prepare(`
    INSERT INTO vapi_call_logs (
      id, tenant_id, call_id, phone_number,
      status, duration_seconds, cost_usd,
      prospect_id, prospect_name, prospect_email,
      functions_called, appointment_created, appointment_id,
      created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    logId,
    data.tenant_id,
    data.call_id,
    data.phone_number || '',
    data.status || 'completed',
    data.duration_seconds || 0,
    data.cost_usd || '0.00',
    data.prospect_id || null,
    data.prospect_name || '',
    data.prospect_email || '',
    JSON.stringify(data.functions_called || []),
    data.appointment_created ? 1 : 0,
    data.appointment_id || null,
    now,
    now
  ).run();
}

// ============================================
// VAPI WEBHOOK HANDLERS
// ============================================

async function handleSearchKnowledge(args, env, tenant) {
  const { query } = args;
  
  const results = await env.DB.prepare(`
    SELECT question, answer, category 
    FROM knowledge_base 
    WHERE tenant_id = ? 
    AND type = 'qa'
    AND (question LIKE ? OR answer LIKE ? OR category LIKE ?)
    LIMIT 3
  `).bind(
    tenant.id,
    `%${query}%`,
    `%${query}%`,
    `%${query}%`
  ).all();

  if (results.results.length === 0) {
    return "Je n'ai pas trouvé d'information spécifique sur ce sujet dans ma base de connaissances.";
  }

  return results.results.map(r => `${r.question} ${r.answer}`).join(' ');
}

async function handleCheckAvailability(args, env, tenant) {
  const { date } = args;
  
  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ? LIMIT 1'
  ).bind(tenant.id).first();

  if (!agent) {
    return "Aucun agent disponible.";
  }

  const url = `https://coccinelle-api.youssef-amrouche.workers.dev/api/v1/agents/${agent.id}/availability?start_date=${date}&end_date=${date}&duration=60`;
  
  const response = await fetch(url, {
    headers: { 'X-API-Key': tenant.api_key }
  });

  const data = await response.json();

  if (!data.available_slots || data.available_slots.length === 0) {
    return "Aucun créneau disponible pour cette date.";
  }

  const slots = data.available_slots.slice(0, 3).map(slot => {
    const time = new Date(slot.start).toLocaleTimeString('fr-FR', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    return time;
  });

  return `Créneaux disponibles : ${slots.join(', ')}`;
}

async function handleCreateAppointment(args, env, tenant, ctx) {
  const { firstName, lastName, phone, email, datetime } = args;
  
  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ? LIMIT 1'
  ).bind(tenant.id).first();

  if (!agent) {
    throw new Error('Aucun agent disponible');
  }

  // Créer prospect
  const prospectId = `prospect_${Date.now()}`;
  await env.DB.prepare(`
    INSERT INTO prospects (id, tenant_id, first_name, last_name, email, phone, status, source, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    prospectId,
    tenant.id,
    firstName,
    lastName,
    email || '',
    phone,
    'qualified',
    'vapi_call',
    new Date().toISOString()
  ).run();

  // Créer RDV
  const appointmentId = `appt_${Date.now()}`;
  const managementToken = generateToken();
  
  await env.DB.prepare(`
    INSERT INTO appointments (
      id, tenant_id, prospect_id, agent_id, type, 
      scheduled_at, status, management_token, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    appointmentId,
    tenant.id,
    prospectId,
    agent.id,
    'visit',
    datetime,
    'confirmed',
    managementToken,
    new Date().toISOString()
  ).run();

  const localDate = new Date(datetime).toLocaleDateString('fr-FR', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  
  const match = datetime.match(/T(\d{2}):(\d{2})/);
  const localTime = match ? `${match[1]}h${match[2]}` : "l'heure demandée";
  
  const formattedDate = localDate;
  
  const formattedTime = `${new Date(datetime).getHours()}h${new Date(datetime).getMinutes().toString().padStart(2, '0')}`;
  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  const confirmationMessage = `Parfait ${firstName} ! Rendez-vous confirmé le ${localDate} à ${localTime}. Vous recevrez une confirmation par SMS et email.`;
  
  ctx.waitUntil(
    (async () => {
      await new Promise(resolve => setTimeout(resolve, 2000));
      await sendAppointmentNotifications(
        env, 
        appointmentId, 
        managementToken,
        firstName,
        datetime, 
        phone, 
        email
      );
    })()
  );

  // Logger l'appel Vapi dans vapi_call_logs
  try {
    await logVapiCall(env, {
      call_id: ctx?.callId || `call_${Date.now()}`,
      tenant_id: tenant.id,
      phone_number: phone,
      status: 'completed',
      prospect_id: prospectId,
      prospect_name: `${firstName} ${lastName}`,
      prospect_email: email,
      functions_called: ['createAppointment'],
      appointment_created: true,
      appointment_id: appointmentId
    });
    console.log('✅ Appel Vapi loggé avec succès');
  } catch (logError) {
    console.error('❌ Erreur logging Vapi:', logError.message);
  }

  return confirmationMessage;
}

// ============================================
// ROUTES - PROSPECTS
// ============================================

router.get('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const prospects = await env.DB.prepare(
    'SELECT * FROM prospects WHERE tenant_id = ? ORDER BY created_at DESC'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ prospects: prospects.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const data = await request.json();
  const prospectId = `prospect_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO prospects (id, tenant_id, first_name, last_name, email, phone, status, source, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    prospectId,
    tenant.id,
    data.first_name || '',
    data.last_name || '',
    data.email || '',
    data.phone || '',
    data.status || 'new',
    data.source || 'api',
    new Date().toISOString()
  ).run();

  return new Response(JSON.stringify({ success: true, prospect_id: prospectId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - AGENTS
// ============================================

router.get('/api/v1/agents', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const agents = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ? ORDER BY created_at DESC'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ agents: agents.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/agents/:agentId/availability', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const { agentId } = request.params;
  const url = new URL(request.url);
  const startDate = url.searchParams.get('start_date');
  const endDate = url.searchParams.get('end_date');
  const duration = parseInt(url.searchParams.get('duration') || '60');

  if (!startDate || !endDate) {
    return new Response(JSON.stringify({ error: 'start_date and end_date required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE id = ? AND tenant_id = ?'
  ).bind(agentId, tenant.id).first();

  if (!agent) {
    return new Response(JSON.stringify({ error: 'Agent not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const slots = await env.DB.prepare(
    'SELECT * FROM availability_slots WHERE agent_id = ? AND tenant_id = ?'
  ).bind(agentId, tenant.id).all();

  const appointments = await env.DB.prepare(
    'SELECT * FROM appointments WHERE agent_id = ? AND scheduled_at >= ? AND scheduled_at <= ? AND status != ?'
  ).bind(agentId, startDate, endDate + 'T23:59:59Z', 'cancelled').all();

  const blocks = await env.DB.prepare(
    'SELECT * FROM calendar_blocks WHERE agent_id = ? AND tenant_id = ? AND start_datetime <= ? AND end_datetime >= ?'
  ).bind(agentId, tenant.id, endDate + 'T23:59:59Z', startDate + 'T00:00:00Z').all();

  const availableSlots = [];
  const start = new Date(startDate);
  const end = new Date(endDate);

  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    const dayOfWeek = d.getDay();
    const dateStr = d.toISOString().split('T')[0];

    const daySlots = slots.results.filter(s => s.day_of_week === dayOfWeek);

    for (const slot of daySlots) {
      let currentTime = new Date(`${dateStr}T${slot.start_time}:00Z`);
      const endTime = new Date(`${dateStr}T${slot.end_time}:00Z`);

      while (currentTime < endTime) {
        const slotEnd = new Date(currentTime.getTime() + duration * 60000);
        
        if (slotEnd > endTime) break;

        const isBlocked = blocks.results.some(block => {
          const blockStart = new Date(block.start_datetime);
          const blockEnd = new Date(block.end_datetime);
          return currentTime >= blockStart && currentTime < blockEnd;
        });

        const hasAppointment = appointments.results.some(appt => {
          const apptTime = new Date(appt.scheduled_at);
          const bufferTime = (agent.buffer_time || 0) * 60000;
          return Math.abs(apptTime.getTime() - currentTime.getTime()) < (duration * 60000 + bufferTime);
        });

        if (!isBlocked && !hasAppointment) {
          availableSlots.push({
            start: currentTime.toISOString(),
            end: slotEnd.toISOString(),
            duration_minutes: duration
          });
        }

        currentTime = new Date(currentTime.getTime() + 30 * 60000);
      }
    }
  }

  return new Response(JSON.stringify({
    success: true,
    agent: {
      id: agent.id,
      name: `${agent.first_name} ${agent.last_name}`,
      buffer_time: agent.buffer_time,
      max_appointments_per_day: agent.max_appointments_per_day
    },
    available_slots: availableSlots,
    period: { start: startDate, end: endDate, duration }
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - APPOINTMENTS
// ============================================

router.get('/api/v1/appointments', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const appointments = await env.DB.prepare(`
    SELECT a.*, p.first_name as prospect_first_name, p.last_name as prospect_last_name,
           ag.first_name as agent_first_name, ag.last_name as agent_last_name
    FROM appointments a
    LEFT JOIN prospects p ON a.prospect_id = p.id
    LEFT JOIN agents ag ON a.agent_id = ag.id
    WHERE a.tenant_id = ?
    ORDER BY a.scheduled_at DESC
  `).bind(tenant.id).all();

  return new Response(JSON.stringify({ appointments: appointments.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/appointments', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const data = await request.json();
  const appointmentId = `appt_${Date.now()}`;
  const managementToken = generateToken();

  await env.DB.prepare(`
    INSERT INTO appointments (
      id, tenant_id, prospect_id, agent_id, property_id, type,
      scheduled_at, status, management_token, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    appointmentId,
    tenant.id,
    data.prospect_id,
    data.agent_id,
    data.property_id || null,
    data.type || 'visit',
    data.scheduled_at,
    'confirmed',
    managementToken,
    new Date().toISOString()
  ).run();

  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  return new Response(JSON.stringify({
    success: true,
    appointment_id: appointmentId,
    management_url: managementUrl,
    management_token: managementToken
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - RDV PUBLIC MANAGEMENT
// ============================================

router.get('/rdv/:token', async (request, env) => {
  const { token } = request.params;

  const appointment = await env.DB.prepare(`
    SELECT a.*, p.first_name, p.last_name, p.phone, p.email,
           ag.first_name as agent_first_name, ag.last_name as agent_last_name
    FROM appointments a
    LEFT JOIN prospects p ON a.prospect_id = p.id
    LEFT JOIN agents ag ON a.agent_id = ag.id
    WHERE a.management_token = ?
  `).bind(token).first();

  if (!appointment) {
    return new Response('Rendez-vous non trouvé', { status: 404 });
  }

  const html = `<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gérer mon rendez-vous</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f7f7f8; padding: 20px; }
    .container { max-width: 600px; margin: 0 auto; background: white; border-radius: 8px; padding: 32px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    h1 { font-size: 24px; font-weight: 600; color: #2d2d2d; margin-bottom: 24px; }
    .info { background: #f7f7f8; padding: 16px; border-radius: 6px; margin-bottom: 24px; }
    .info-row { display: flex; padding: 8px 0; border-bottom: 1px solid #e5e5e5; }
    .info-row:last-child { border-bottom: none; }
    .label { font-weight: 500; color: #666; min-width: 120px; }
    .value { color: #2d2d2d; }
    .status { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 500; }
    .status.confirmed { background: #d1fae5; color: #065f46; }
    .status.cancelled { background: #fee2e2; color: #991b1b; }
    .actions { display: flex; gap: 12px; margin-top: 24px; }
    button { flex: 1; padding: 12px; border: none; border-radius: 6px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .btn-modify { background: #f7f7f8; color: #2d2d2d; }
    .btn-modify:hover { background: #e5e5e5; }
    .btn-cancel { background: #fee2e2; color: #991b1b; }
    .btn-cancel:hover { background: #fecaca; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gérer mon rendez-vous</h1>
    <div class="info">
      <div class="info-row">
        <span class="label">Statut</span>
        <span class="value"><span class="status ${appointment.status}">${appointment.status === 'confirmed' ? 'Confirmé' : 'Annulé'}</span></span>
      </div>
      <div class="info-row">
        <span class="label">Date</span>
        <span class="value">${new Date(appointment.scheduled_at).toLocaleString('fr-FR')}</span>
      </div>
      <div class="info-row">
        <span class="label">Agent</span>
        <span class="value">${appointment.agent_first_name} ${appointment.agent_last_name}</span>
      </div>
      <div class="info-row">
        <span class="label">Contact</span>
        <span class="value">${appointment.first_name} ${appointment.last_name}</span>
      </div>
    </div>
    ${appointment.status === 'confirmed' ? `
    <div class="actions">
      <button class="btn-modify" onclick="showModifyForm()">Modifier</button>
      <button class="btn-cancel" onclick="cancelAppointment()">Annuler</button>
    </div>
    ` : ''}
  </div>
  <script>
    async function cancelAppointment() {
      if (!confirm('Êtes-vous sûr de vouloir annuler ce rendez-vous ?')) return;
      const res = await fetch('/rdv/${token}/cancel', { method: 'POST' });
      if (res.ok) location.reload();
    }
    async function showModifyForm() {
      const agentId = '${appointment.agent_id}';
      const res = await fetch('/rdv/${token}/availability?agent_id=' + agentId);
      const data = await res.json();
      alert('Fonctionnalité de modification disponible avec ' + data.available_slots.length + ' créneaux');
    }
  </script>
</body>
</html>`;

  return new Response(html, {
    headers: { 'Content-Type': 'text/html', ...corsHeaders() }
  });
});

router.get('/rdv/:token/availability', async (request, env) => {
  const { token } = request.params;
  
  const appointment = await env.DB.prepare(
    'SELECT * FROM appointments WHERE management_token = ?'
  ).bind(token).first();

  if (!appointment) {
    return new Response(JSON.stringify({ error: 'Appointment not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const url = new URL(request.url);
  const agentId = appointment.agent_id;
  const today = new Date().toISOString().split('T')[0];
  const endDate = new Date();
  endDate.setDate(endDate.getDate() + 14);
  const endDateStr = endDate.toISOString().split('T')[0];

  const tenant = await env.DB.prepare(
    'SELECT * FROM tenants WHERE id = ?'
  ).bind(appointment.tenant_id).first();

  const internalUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/api/v1/agents/${agentId}/availability?start_date=${today}&end_date=${endDateStr}&duration=60`;
  
  const response = await fetch(internalUrl, {
    headers: { 'X-API-Key': tenant.api_key }
  });

  const data = await response.json();

  return new Response(JSON.stringify(data), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/rdv/:token/cancel', async (request, env) => {
  const { token } = request.params;

  await env.DB.prepare(
    'UPDATE appointments SET status = ? WHERE management_token = ?'
  ).bind('cancelled', token).run();

  return new Response(JSON.stringify({ success: true }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - VAPI
// ============================================

router.post('/webhooks/vapi/function-call', async (request, env, ctx) => {
  try {
    const payload = await request.json();
    const functionName = payload.message?.functionCall?.name;
    const args = payload.message?.functionCall?.parameters || {};
    
    const phoneNumber = payload.message?.call?.customer?.number;
    
    let tenant = await env.DB.prepare(
      'SELECT * FROM tenants WHERE vapi_phone_number = ? LIMIT 1'
    ).bind(phoneNumber).first();

    if (!tenant) {
      tenant = await env.DB.prepare('SELECT * FROM tenants LIMIT 1').first();
    }

    let result;

    switch (functionName) {
      case 'searchKnowledge':
        result = await handleSearchKnowledge(args, env, tenant);
        break;
      case 'checkAvailability':
        result = await handleCheckAvailability(args, env, tenant);
        break;
      case 'createAppointment':
        result = await handleCreateAppointment(args, env, tenant, ctx);
        break;
      default:
        result = 'Fonction non reconnue';
    }

    return new Response(JSON.stringify({
      results: [{
        toolCallId: payload.message?.toolCallId,
        result: result
      }]
    }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Erreur webhook Vapi:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});

// ============================================
// ROUTES - VAPI LOGS
// ============================================

router.get('/api/v1/vapi/calls', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const url = new URL(request.url);
  const status = url.searchParams.get('status');
  const prospectId = url.searchParams.get('prospect_id');

  let query = 'SELECT * FROM vapi_call_logs WHERE tenant_id = ?';
  const params = [tenant.id];

  if (status) {
    query += ' AND status = ?';
    params.push(status);
  }

  if (prospectId) {
    query += ' AND prospect_id = ?';
    params.push(prospectId);
  }

  query += ' ORDER BY created_at DESC LIMIT 50';

  const calls = await env.DB.prepare(query).bind(...params).all();

  return new Response(JSON.stringify({ calls: calls.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/vapi/calls/:callId', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const { callId } = request.params;

  const call = await env.DB.prepare(
    'SELECT * FROM vapi_call_logs WHERE call_id = ? AND tenant_id = ?'
  ).bind(callId, tenant.id).first();

  if (!call) {
    return new Response(JSON.stringify({ error: 'Call not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  return new Response(JSON.stringify({ call }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/vapi/stats', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const stats = await env.DB.prepare(`
    SELECT 
      COUNT(*) as total_calls,
      SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_calls,
      SUM(CASE WHEN appointment_created = 1 THEN 1 ELSE 0 END) as appointments_created,
      AVG(duration_seconds) as avg_duration_seconds,
      SUM(CAST(cost_usd AS REAL)) as total_cost_usd,
      AVG(sentiment_score) as avg_sentiment
    FROM vapi_call_logs
    WHERE tenant_id = ?
  `).bind(tenant.id).first();

  const conversionRate = stats.total_calls > 0 
    ? ((stats.appointments_created / stats.completed_calls) * 100).toFixed(0) + '%'
    : '0%';

  return new Response(JSON.stringify({
    success: true,
    stats: {
      total_calls: stats.total_calls || 0,
      completed_calls: stats.completed_calls || 0,
      appointments_created: stats.appointments_created || 0,
      conversion_rate: conversionRate,
      avg_duration_seconds: Math.round(stats.avg_duration_seconds || 0),
      total_cost_usd: (stats.total_cost_usd || 0).toFixed(2),
      avg_sentiment: (stats.avg_sentiment || 0).toFixed(2)
    }
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// OPTIONS HANDLER (CORS)
// ============================================

router.options('*', () => {
  return new Response(null, {
    headers: corsHeaders()
  });
});

// ============================================
// MAIN HANDLER
// ============================================

export default {
  async fetch(request, env, ctx) {
    return router.handle(request, env, ctx).catch(err => {
      console.error('Error:', err);
      return new Response(JSON.stringify({ error: err.message }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders() }
      });
    });
  }
};
