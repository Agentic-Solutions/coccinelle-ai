import { Router } from 'itty-router';

const router = Router();

// ============================================
// HELPERS & UTILITIES
// ============================================

function generateToken() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

function corsHeaders() {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, X-API-Key',
  };
}

// ============================================
// AUTHENTICATION MIDDLEWARE
// ============================================

async function authenticateRequest(request, env) {
  const apiKey = request.headers.get('X-API-Key');
  
  if (!apiKey) {
    return new Response(JSON.stringify({ error: 'API Key required' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const tenant = await env.DB.prepare(
    'SELECT * FROM tenants WHERE api_key = ?'
  ).bind(apiKey).first();

  if (!tenant) {
    return new Response(JSON.stringify({ error: 'Invalid API Key' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  return tenant;
}

// ============================================
// NOTIFICATION HELPERS
// ============================================

async function sendAppointmentNotifications(env, appointmentId, managementToken, firstName, datetime, phone, email) {
  const localDate = new Date(datetime).toLocaleDateString('fr-FR', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  
  const formattedTime = `${new Date(datetime).getHours()}h${new Date(datetime).getMinutes().toString().padStart(2, '0')}`;
  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  // SMS
  if (phone && env.TWILIO_ACCOUNT_SID && env.TWILIO_AUTH_TOKEN) {
    try {
      const smsBody = `Bonjour ${firstName}, RDV confirm√© le ${localDate} √† ${formattedTime}. G√©rer: ${managementUrl}`;
      
      const twilioResponse = await fetch(
        `https://api.twilio.com/2010-04-01/Accounts/${env.TWILIO_ACCOUNT_SID}/Messages.json`,
        {
          method: 'POST',
          headers: {
            'Authorization': 'Basic ' + btoa(`${env.TWILIO_ACCOUNT_SID}:${env.TWILIO_AUTH_TOKEN}`),
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            To: phone,
            From: env.TWILIO_PHONE_NUMBER,
            Body: smsBody
          })
        }
      );

      if (twilioResponse.ok) {
        const twilioData = await twilioResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `).bind(
          `notif_${Date.now()}_sms`,
          appointmentId,
          'sms',
          phone,
          'sent',
          twilioData.sid,
          new Date().toISOString()
        ).run();
      }
    } catch (error) {
      console.error('Erreur SMS:', error);
    }
  }

  // Email
  if (email && email !== 'noemail@placeholder.com' && env.RESEND_API_KEY) {
    try {
      const emailResponse = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${env.RESEND_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          from: env.RESEND_FROM_EMAIL || 'onboarding@resend.dev',
          to: [email],
          subject: `Confirmation de rendez-vous - ${localDate}`,
          html: `
            <h2>Rendez-vous confirm√©</h2>
            <p>Bonjour ${firstName},</p>
            <p>Votre rendez-vous est confirm√© pour le <strong>${localDate}</strong> √† <strong>${formattedTime}</strong>.</p>
            <p><a href="${managementUrl}">G√©rer mon rendez-vous</a></p>
          `
        })
      });

      if (emailResponse.ok) {
        const emailData = await emailResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `).bind(
          `notif_${Date.now()}_email`,
          appointmentId,
          'email',
          email,
          'sent',
          emailData.id,
          new Date().toISOString()
        ).run();
      }
    } catch (error) {
      console.error('Erreur Email:', error);
    }
  }
}

// ============================================
// VAPI LOGGING HELPER
// ============================================

async function logVapiCall(env, data) {
  const logId = `log_${Date.now()}`;
  const now = new Date().toISOString();
  
  await env.DB.prepare(`
    INSERT INTO vapi_call_logs (
      id, tenant_id, call_id, phone_number,
      status, duration_seconds, cost_usd,
      prospect_id, prospect_name, prospect_email,
      functions_called, appointment_created, appointment_id,
      created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    logId,
    data.tenant_id,
    data.call_id,
    data.phone_number || '',
    data.status || 'completed',
    data.duration_seconds || 0,
    data.cost_usd || '0.00',
    data.prospect_id || null,
    data.prospect_name || '',
    data.prospect_email || '',
    JSON.stringify(data.functions_called || []),
    data.appointment_created ? 1 : 0,
    data.appointment_id || null,
    now,
    now
  ).run();
}

// ============================================
// VAPI WEBHOOK HANDLERS
// ============================================

async function handleSearchKnowledge(args, env, tenant) {
  const { query } = args;
  
  const results = await env.DB.prepare(`
    SELECT question, answer, category
    FROM knowledge_base
    WHERE tenant_id = ?
    AND type = 'qa'
    AND (question LIKE ? OR answer LIKE ? OR category LIKE ?)
    LIMIT 3
  `).bind(tenant.id, `%${query}%`, `%${query}%`, `%${query}%`).all();

  if (results.results.length === 0) {
    return "Je n'ai pas trouv√© d'information sur ce sujet dans ma base de connaissances.";
  }

  return results.results.map(r => `${r.question}\n${r.answer}`).join('\n\n');
}

async function handleCheckAvailability(args, env, tenant) {
  const { date } = args;
  
  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ? LIMIT 1'
  ).bind(tenant.id).first();

  if (!agent) {
    return "Aucun agent disponible pour le moment.";
  }

  const requestedDate = new Date(date);
  const dayOfWeek = requestedDate.getDay() || 7;
  
  const slots = await env.DB.prepare(`
    SELECT start_time, end_time
    FROM availability_slots
    WHERE agent_id = ? AND day_of_week = ?
  `).bind(agent.id, dayOfWeek).all();

  if (!slots.results || slots.results.length === 0) {
    return `D√©sol√©, je n'ai pas de disponibilit√©s ce jour-l√†. Souhaitez-vous un autre jour ?`;
  }

  const availableSlots = [];
  for (const slot of slots.results) {
    const [startHour, startMin] = slot.start_time.split(':');
    const [endHour, endMin] = slot.end_time.split(':');
    
    availableSlots.push(`${startHour}h${startMin}`);
  }

  return `Pour le ${requestedDate.toLocaleDateString('fr-FR')}, j'ai ces cr√©neaux disponibles : ${availableSlots.slice(0, 3).join(', ')}. Lequel vous convient ?`;
}

async function handleCreateAppointment(args, env, tenant, callId, phoneNumber) {
  const { firstName, lastName, phone, email, datetime } = args;
  
  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ? LIMIT 1'
  ).bind(tenant.id).first();

  if (!agent) {
    throw new Error('Aucun agent disponible');
  }

  // Cr√©er prospect
  const prospectId = `prospect_${Date.now()}`;
  await env.DB.prepare(`
    INSERT INTO prospects (id, tenant_id, first_name, last_name, email, phone, status, source, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    prospectId,
    tenant.id,
    firstName,
    lastName,
    email || '',
    phone,
    'qualified',
    'vapi_call',
    new Date().toISOString()
  ).run();

  // Cr√©er RDV
  const appointmentId = `appt_${Date.now()}`;
  const managementToken = generateToken();
  
  await env.DB.prepare(`
    INSERT INTO appointments (
      id, tenant_id, prospect_id, agent_id, type, 
      scheduled_at, status, management_token, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    appointmentId,
    tenant.id,
    prospectId,
    agent.id,
    'visit',
    datetime,
    'confirmed',
    managementToken,
    new Date().toISOString()
  ).run();

  const localDate = new Date(datetime).toLocaleDateString('fr-FR', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  
  const match = datetime.match(/T(\d{2}):(\d{2})/);
  const localTime = match ? `${match[1]}h${match[2]}` : "l'heure demand√©e";
  
  const confirmationMessage = `Parfait ${firstName} ! Rendez-vous confirm√© le ${localDate} √† ${localTime}. Vous recevrez une confirmation par SMS et email.`;
  
  // Envoyer notifications (async)
  setTimeout(() => {
    sendAppointmentNotifications(
      env, 
      appointmentId, 
      managementToken,
      firstName,
      datetime, 
      phone, 
      email
    );
  }, 2000);

  // ‚úÖ CORRECTION : Logger l'appel Vapi avec le vrai callId
  try {
    await logVapiCall(env, {
      call_id: callId || `call_${Date.now()}`,
      tenant_id: tenant.id,
      phone_number: phoneNumber || phone,
      status: 'completed',
      prospect_id: prospectId,
      prospect_name: `${firstName} ${lastName}`,
      prospect_email: email || '',
      functions_called: ['createAppointment'],
      appointment_created: true,
      appointment_id: appointmentId
    });
    console.log('‚úÖ Appel Vapi logg√© avec succ√®s:', callId);
  } catch (logError) {
    console.error('‚ùå Erreur logging Vapi:', logError.message);
  }

  return confirmationMessage;
}

// ============================================
// ROUTES - PROSPECTS
// ============================================

router.get('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const prospects = await env.DB.prepare(
    'SELECT * FROM prospects WHERE tenant_id = ? ORDER BY created_at DESC'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ prospects: prospects.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const body = await request.json();
  const prospectId = `prospect_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO prospects (id, tenant_id, name, email, phone, status, source, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    prospectId,
    tenant.id,
    body.name,
    body.email || '',
    body.phone || '',
    body.status || 'new',
    body.source || 'api',
    new Date().toISOString()
  ).run();

  return new Response(JSON.stringify({ success: true, id: prospectId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - AGENTS
// ============================================

router.get('/api/v1/agents', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const agents = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ agents: agents.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/agents/:agentId/availability', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const { agentId } = request.params;
  const url = new URL(request.url);
  const startDate = url.searchParams.get('start_date');
  const endDate = url.searchParams.get('end_date');
  const duration = parseInt(url.searchParams.get('duration') || '60');

  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE id = ? AND tenant_id = ?'
  ).bind(agentId, tenant.id).first();

  if (!agent) {
    return new Response(JSON.stringify({ error: 'Agent not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const slots = await env.DB.prepare(
    'SELECT * FROM availability_slots WHERE agent_id = ?'
  ).bind(agentId).all();

  const availableSlots = [];
  const start = new Date(startDate);
  const end = new Date(endDate);

  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    const dayOfWeek = d.getDay() || 7;
    const daySlots = slots.results.filter(s => s.day_of_week === dayOfWeek);

    for (const slot of daySlots) {
      const [startHour, startMin] = slot.start_time.split(':');
      const [endHour, endMin] = slot.end_time.split(':');
      
      const slotStart = new Date(d);
      slotStart.setHours(parseInt(startHour), parseInt(startMin), 0);
      
      const slotEnd = new Date(d);
      slotEnd.setHours(parseInt(endHour), parseInt(endMin), 0);

      availableSlots.push({
        start: slotStart.toISOString(),
        end: slotEnd.toISOString(),
        duration_minutes: duration
      });
    }
  }

  return new Response(JSON.stringify({
    success: true,
    agent: {
      id: agent.id,
      name: agent.name,
      buffer_time: agent.buffer_time,
      max_appointments_per_day: agent.max_appointments_per_day
    },
    available_slots: availableSlots,
    period: { start: startDate, end: endDate, duration }
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - SERVICES
// ============================================

router.get('/api/v1/services', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const services = await env.DB.prepare(
    'SELECT * FROM services WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ services: services.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/services', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const body = await request.json();
  const serviceId = `service_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO services (id, tenant_id, name, description, category, duration_minutes)
    VALUES (?, ?, ?, ?, ?, ?)
  `).bind(
    serviceId,
    tenant.id,
    body.name,
    body.description || '',
    body.category || 'general',
    body.duration_minutes || 60
  ).run();

  return new Response(JSON.stringify({ success: true, id: serviceId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - KNOWLEDGE BASE
// ============================================

router.get('/api/v1/knowledge-base', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const kb = await env.DB.prepare(
    'SELECT * FROM knowledge_base WHERE tenant_id = ? ORDER BY created_at DESC'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ knowledge_base: kb.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/knowledge-base', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const body = await request.json();
  const kbId = `kb_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO knowledge_base (id, tenant_id, type, category, question, answer, document_url, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    kbId,
    tenant.id,
    body.type || 'qa',
    body.category || 'general',
    body.question || '',
    body.answer || '',
    body.document_url || '',
    new Date().toISOString()
  ).run();

  return new Response(JSON.stringify({ success: true, id: kbId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// ROUTES - APPOINTMENTS
// ============================================

router.get('/api/v1/appointments', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const appointments = await env.DB.prepare(
    'SELECT * FROM appointments WHERE tenant_id = ? ORDER BY scheduled_at DESC'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ appointments: appointments.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.post('/api/v1/appointments', async (request, env, ctx) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const body = await request.json();
  const appointmentId = `appt_${Date.now()}`;
  const managementToken = generateToken();

  await env.DB.prepare(`
    INSERT INTO appointments (
      id, tenant_id, prospect_id, agent_id, service_id, type,
      scheduled_at, status, management_token, notes, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    appointmentId,
    tenant.id,
    body.prospect_id,
    body.agent_id,
    body.service_id || null,
    body.type || 'visit',
    body.scheduled_at,
    'scheduled',
    managementToken,
    body.notes || '',
    new Date().toISOString()
  ).run();

  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  return new Response(JSON.stringify({
    success: true,
    id: appointmentId,
    management_token: managementToken,
    management_url: managementUrl
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/rdv/:token', async (request, env) => {
  const { token } = request.params;

  const appointment = await env.DB.prepare(
    'SELECT * FROM appointments WHERE management_token = ?'
  ).bind(token).first();

  if (!appointment) {
    return new Response('Rendez-vous introuvable', { status: 404 });
  }

  const prospect = await env.DB.prepare(
    'SELECT * FROM prospects WHERE id = ?'
  ).bind(appointment.prospect_id).first();

  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE id = ?'
  ).bind(appointment.agent_id).first();

  const html = `
    <!DOCTYPE html>
    <html lang="fr">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Gestion de rendez-vous</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: #f5f5f5;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background: white;
          border-radius: 8px;
          padding: 32px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        h1 { color: #1a1a1a; font-size: 24px; margin-bottom: 24px; }
        .info { margin: 16px 0; padding: 16px; background: #f9f9f9; border-radius: 6px; }
        .label { font-weight: 500; color: #666; margin-bottom: 4px; }
        .value { color: #1a1a1a; font-size: 16px; }
        .status { display: inline-block; padding: 4px 12px; border-radius: 4px; font-size: 14px; }
        .status.confirmed { background: #d4edda; color: #155724; }
        .status.cancelled { background: #f8d7da; color: #721c24; }
        button {
          background: #007bff;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 16px;
          margin: 8px 8px 8px 0;
        }
        button:hover { background: #0056b3; }
        .btn-cancel { background: #dc3545; }
        .btn-cancel:hover { background: #c82333; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>Votre rendez-vous</h1>
        <div class="info">
          <div class="label">Statut</div>
          <span class="status ${appointment.status}">${appointment.status === 'confirmed' ? 'Confirm√©' : 'Annul√©'}</span>
        </div>
        <div class="info">
          <div class="label">Date et heure</div>
          <div class="value">${new Date(appointment.scheduled_at).toLocaleString('fr-FR')}</div>
        </div>
        <div class="info">
          <div class="label">Agent</div>
          <div class="value">${agent?.name || 'Non d√©fini'}</div>
        </div>
        <div class="info">
          <div class="label">Prospect</div>
          <div class="value">${prospect?.first_name || prospect?.name || 'Non d√©fini'}</div>
        </div>
        ${appointment.status === 'confirmed' ? `
          <button onclick="window.location.href='/rdv/${token}/modify'">Modifier</button>
          <button class="btn-cancel" onclick="if(confirm('Confirmer l\\'annulation ?')) window.location.href='/rdv/${token}/cancel'">Annuler</button>
        ` : ''}
      </div>
    </body>
    </html>
  `;

  return new Response(html, {
    headers: { 'Content-Type': 'text/html', ...corsHeaders() }
  });
});

router.get('/rdv/:token/availability', async (request, env) => {
  const { token } = request.params;

  const appointment = await env.DB.prepare(
    'SELECT * FROM appointments WHERE management_token = ?'
  ).bind(token).first();

  if (!appointment) {
    return new Response(JSON.stringify({ error: 'Appointment not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  const agent = await env.DB.prepare(
    'SELECT * FROM agents WHERE id = ?'
  ).bind(appointment.agent_id).first();

  const url = new URL(request.url);
  const startDate = url.searchParams.get('start_date') || new Date().toISOString().split('T')[0];
  const endDate = url.searchParams.get('end_date') || new Date(Date.now() + 7*24*60*60*1000).toISOString().split('T')[0];

  const slots = await env.DB.prepare(
    'SELECT * FROM availability_slots WHERE agent_id = ?'
  ).bind(appointment.agent_id).all();

  const availableSlots = [];
  const start = new Date(startDate);
  const end = new Date(endDate);

  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    const dayOfWeek = d.getDay() || 7;
    const daySlots = slots.results.filter(s => s.day_of_week === dayOfWeek);

    for (const slot of daySlots) {
      const [startHour, startMin] = slot.start_time.split(':');
      availableSlots.push({
        start: new Date(d.setHours(parseInt(startHour), parseInt(startMin))).toISOString(),
        duration_minutes: 60
      });
    }
  }

  return new Response(JSON.stringify({ available_slots: availableSlots }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// WEBHOOKS - VAPI
// ============================================

router.post('/webhooks/vapi/function-call', async (request, env, ctx) => {
  try {
    const payload = await request.json();
    const functionName = payload.message?.functionCall?.name;
    const args = payload.message?.functionCall?.parameters || {};
    
    // ‚úÖ CORRECTION : Extraire le callId et phoneNumber du payload Vapi
    const callId = payload.message?.call?.id || `call_${Date.now()}`;
    const phoneNumber = payload.message?.call?.customer?.number;
    
    console.log('üìû Webhook Vapi re√ßu:', {
      functionName,
      callId,
      phoneNumber,
      args
    });
    
    let tenant = await env.DB.prepare(
      'SELECT * FROM tenants WHERE vapi_phone_number = ? LIMIT 1'
    ).bind(phoneNumber).first();

    if (!tenant) {
      tenant = await env.DB.prepare('SELECT * FROM tenants LIMIT 1').first();
    }

    let result;

    switch (functionName) {
      case 'searchKnowledge':
        result = await handleSearchKnowledge(args, env, tenant);
        break;
      case 'checkAvailability':
        result = await handleCheckAvailability(args, env, tenant);
        break;
      case 'createAppointment':
        // ‚úÖ CORRECTION : Passer callId et phoneNumber √† handleCreateAppointment
        result = await handleCreateAppointment(args, env, tenant, callId, phoneNumber);
        break;
      default:
        result = 'Fonction non reconnue';
    }

    return new Response(JSON.stringify({
      results: [{
        toolCallId: payload.message?.toolCallId,
        result: result
      }]
    }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('‚ùå Erreur webhook Vapi:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});

// ============================================
// ROUTES - VAPI LOGS
// ============================================

router.get('/api/v1/vapi/calls', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const url = new URL(request.url);
  const status = url.searchParams.get('status');
  const prospectId = url.searchParams.get('prospect_id');

  let query = 'SELECT * FROM vapi_call_logs WHERE tenant_id = ?';
  const params = [tenant.id];

  if (status) {
    query += ' AND status = ?';
    params.push(status);
  }

  if (prospectId) {
    query += ' AND prospect_id = ?';
    params.push(prospectId);
  }

  query += ' ORDER BY created_at DESC LIMIT 50';

  const calls = await env.DB.prepare(query).bind(...params).all();

  return new Response(JSON.stringify({ calls: calls.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/vapi/calls/:callId', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const { callId } = request.params;

  const call = await env.DB.prepare(
    'SELECT * FROM vapi_call_logs WHERE call_id = ? AND tenant_id = ?'
  ).bind(callId, tenant.id).first();

  if (!call) {
    return new Response(JSON.stringify({ error: 'Call not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders() }
    });
  }

  return new Response(JSON.stringify({ call }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

router.get('/api/v1/vapi/stats', async (request, env) => {
  const tenant = await authenticateRequest(request, env);
  if (tenant instanceof Response) return tenant;

  const stats = await env.DB.prepare(`
    SELECT 
      COUNT(*) as total_calls,
      SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_calls,
      SUM(CASE WHEN appointment_created = 1 THEN 1 ELSE 0 END) as appointments_created,
      AVG(duration_seconds) as avg_duration_seconds,
      SUM(CAST(cost_usd AS REAL)) as total_cost_usd,
      AVG(sentiment_score) as avg_sentiment
    FROM vapi_call_logs
    WHERE tenant_id = ?
  `).bind(tenant.id).first();

  const conversionRate = stats.total_calls > 0 
    ? ((stats.appointments_created / stats.completed_calls) * 100).toFixed(0) + '%'
    : '0%';

  return new Response(JSON.stringify({
    success: true,
    stats: {
      total_calls: stats.total_calls || 0,
      completed_calls: stats.completed_calls || 0,
      appointments_created: stats.appointments_created || 0,
      conversion_rate: conversionRate,
      avg_duration_seconds: Math.round(stats.avg_duration_seconds || 0),
      total_cost_usd: (stats.total_cost_usd || 0).toFixed(2),
      avg_sentiment: (stats.avg_sentiment || 0).toFixed(2)
    }
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders() }
  });
});

// ============================================
// OPTIONS HANDLER (CORS)
// ============================================

router.options('*', () => {
  return new Response(null, {
    headers: corsHeaders()
  });
});

// ============================================
// MAIN HANDLER
// ============================================

export default {
  async fetch(request, env, ctx) {
    return router.handle(request, env, ctx).catch(err => {
      console.error('Error:', err);
      return new Response(JSON.stringify({ error: err.message }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders() }
      });
    });
  }
};
