/**
 * =====================================================
 * COCCINELLE.AI - AUTOPILOT ONBOARDING ROUTES
 * Version : v2.8.0
 * Date : 24 octobre 2025
 * Description : Routes API pour le systÃ¨me d'onboarding automatisÃ©
 * =====================================================
 */

import { initializeProductCategories } from '../products/categories-init.js';
import { syncOnboardingToOmnichannel } from './sync-omnichannel.js';

/**
 * GÃ©nÃ¨re un ID unique pour une session d'onboarding
 */
function generateOnboardingId() {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 11);
  return `onb_${timestamp}_${random}`;
}

/**
 * GÃ©nÃ¨re un ID unique gÃ©nÃ©rique
 */
function generateId(prefix) {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `${prefix}_${timestamp}_${random}`;
}

/**
 * Calcule le pourcentage de progression
 */
function calculateProgress(currentStep, totalSteps) {
  return Math.round((currentStep / totalSteps) * 100);
}

/**
 * GÃ©nÃ¨re des agents par dÃ©faut selon l'industrie
 */
async function generateDefaultAgents(env, tenantId, industry, companyName) {
  // RÃ©cupÃ©rer le template de l'industrie
  const template = await env.DB.prepare(`
    SELECT default_agents FROM onboarding_templates
    WHERE industry = ? AND is_active = 1
  `).bind(industry).first();

  if (!template) {
    // Fallback: agents gÃ©nÃ©riques
    return [
      {
        id: generateId('agent'),
        name: 'Agent Principal',
        email: `agent@${companyName.toLowerCase().replace(/\s+/g, '')}.com`,
        speciality: 'GÃ©nÃ©ral'
      }
    ];
  }

  const agentTemplates = JSON.parse(template.default_agents);
  const emailDomain = companyName.toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
  
  const agents = [];
  
  for (const agentTemplate of agentTemplates.slice(0, 2)) { // Max 2 agents par dÃ©faut
    const agentId = generateId('agent');
    const email = `${agentTemplate.email_suffix}@${emailDomain}.com`;
    
    // CrÃ©er l'agent dans la base
    await env.DB.prepare(`
      INSERT INTO commercial_agents (
        id, tenant_id, name, email, speciality, 
        status, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, 'active', ?, ?)
    `).bind(
      agentId,
      tenantId,
      agentTemplate.name,
      email,
      agentTemplate.speciality,
      new Date().toISOString(),
      new Date().toISOString()
    ).run();
    
    // CrÃ©er disponibilitÃ©s par dÃ©faut (9h-18h, Lun-Ven)
    const days = [1, 2, 3, 4, 5]; // Lundi Ã  Vendredi
    for (const day of days) {
      const slotId = generateId('slot');
      await env.DB.prepare(`
        INSERT INTO availability_slots (
          id, agent_id, day_of_week, start_time, end_time, is_available
        ) VALUES (?, ?, ?, '09:00', '18:00', 1)
      `).bind(slotId, agentId, day).run();
    }
    
    agents.push({
      id: agentId,
      name: agentTemplate.name,
      email: email,
      speciality: agentTemplate.speciality
    });
  }
  
  return agents;
}

/**
 * GÃ©nÃ¨re le prompt VAPI personnalisÃ© selon l'industrie
 */
async function generateVapiPrompt(env, industry, companyName) {
  const template = await env.DB.prepare(`
    SELECT vapi_system_prompt, vapi_first_message 
    FROM onboarding_templates
    WHERE industry = ? AND is_active = 1
  `).bind(industry).first();

  if (!template) {
    // Fallback gÃ©nÃ©rique
    return {
      systemPrompt: `Tu es Sara, assistante vocale pour ${companyName}. Tu aides les clients Ã  prendre rendez-vous.`,
      firstMessage: `Bonjour, je suis Sara de ${companyName}. Comment puis-je vous aider ?`
    };
  }

  return {
    systemPrompt: template.vapi_system_prompt.replace('{COMPANY_NAME}', companyName),
    firstMessage: template.vapi_first_message.replace('{COMPANY_NAME}', companyName)
  };
}

/**
 * Initialise la Knowledge Base avec des documents par dÃ©faut
 */
async function initializeKnowledgeBase(env, tenantId, industry, companyName) {
  const template = await env.DB.prepare(`
    SELECT default_documents, default_faqs 
    FROM onboarding_templates
    WHERE industry = ? AND is_active = 1
  `).bind(industry).first();

  if (!template) {
    return { documentsCreated: 0, faqsCreated: 0 };
  }

  const documents = JSON.parse(template.default_documents);
  const faqs = JSON.parse(template.default_faqs);
  
  let documentsCreated = 0;
  let faqsCreated = 0;

  // CrÃ©er les documents
  for (const doc of documents) {
    const docId = generateId('doc');
    const contentHash = `hash_${Date.now()}_${Math.random()}`;
    
    await env.DB.prepare(`
      INSERT INTO knowledge_documents (
        id, tenant_id, title, content, source_type, source_url,
        content_hash, metadata, status, created_at, updated_at
      ) VALUES (?, ?, ?, ?, 'template', '', ?, '{}', 'pending', ?, ?)
    `).bind(
      docId,
      tenantId,
      doc.title,
      doc.content,
      contentHash,
      new Date().toISOString(),
      new Date().toISOString()
    ).run();
    
    documentsCreated++;
  }

  // CrÃ©er les FAQs dans knowledge_base (legacy table si elle existe)
  for (const faq of faqs) {
    const faqId = generateId('kb');
    
    try {
      await env.DB.prepare(`
        INSERT INTO knowledge_base (
          id, tenant_id, question, answer, category, created_at
        ) VALUES (?, ?, ?, ?, 'onboarding', ?)
      `).bind(
        faqId,
        tenantId,
        faq.question,
        faq.answer,
        new Date().toISOString()
      ).run();
      
      faqsCreated++;
    } catch (error) {
      console.log('FAQ insertion failed (table may not exist):', error.message);
    }
  }

  return { documentsCreated, faqsCreated };
}

/**
 * =====================================================
 * ROUTES ONBOARDING
 * =====================================================
 */

/**
 * POST /api/v1/onboarding/start
 * DÃ©marre une nouvelle session d'onboarding
 */
export async function startOnboarding(request, env, tenantId, userId) {
  try {
    const sessionId = generateOnboardingId();
    const analyticsId = generateId('ona');
    const now = new Date().toISOString();

    // RÃ©cupÃ©rer IP et User-Agent
    const ipAddress = request.headers.get('cf-connecting-ip') || 
                     request.headers.get('x-forwarded-for') || 
                     'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';

    // CrÃ©er la session d'onboarding
    await env.DB.prepare(`
      INSERT INTO onboarding_sessions (
        id, tenant_id, user_id, current_step, total_steps,
        progress_percentage, status, source, started_at,
        last_updated_at, ip_address, user_agent, is_active
      ) VALUES (?, ?, ?, 1, 6, 0, 'in_progress', 'web', ?, ?, ?, ?, 1)
    `).bind(
      sessionId,
      tenantId,
      userId,
      now,
      now,
      ipAddress,
      userAgent
    ).run();

    // CrÃ©er l'entrÃ©e analytics
    await env.DB.prepare(`
      INSERT INTO onboarding_analytics (
        id, session_id, tenant_id, created_at
      ) VALUES (?, ?, ?, ?)
    `).bind(analyticsId, sessionId, tenantId, now).run();

    return {
      success: true,
      session: {
        id: sessionId,
        current_step: 1,
        total_steps: 6,
        progress: 0,
        status: 'in_progress',
        started_at: now
      }
    };

  } catch (error) {
    console.error('Error starting onboarding:', error);
    return {
      success: false,
      error: 'Erreur lors du dÃ©marrage de l\'onboarding',
      details: error.message
    };
  }
}

/**
 * PUT /api/v1/onboarding/:id/step
 * Met Ã  jour une Ã©tape et avance la progression
 */
export async function updateOnboardingStep(request, env, sessionId, tenantId) {
  try {
    const body = await request.json();
    const { step, data, moveToNext = true } = body;

    if (!step || !data) {
      return {
        success: false,
        error: 'ParamÃ¨tres manquants: step et data requis'
      };
    }

    // VÃ©rifier que la session existe et appartient au tenant
    const session = await env.DB.prepare(`
      SELECT * FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session) {
      return {
        success: false,
        error: 'Session d\'onboarding non trouvÃ©e'
      };
    }

    // DÃ©terminer le champ JSON Ã  mettre Ã  jour
    let jsonField = '';
    
    switch (step) {
      case 1:
      case 2:
        jsonField = 'business_data';
        break;
      case 3:
        jsonField = 'agents_data';
        break;
      case 4:
        jsonField = 'vapi_data';
        break;
      case 5:
        jsonField = 'kb_data';
        break;
      case 6:
        jsonField = 'completion_data';
        break;
      default:
        return {
          success: false,
          error: 'NumÃ©ro d\'Ã©tape invalide'
        };
    }

    const now = new Date().toISOString();
    const newStep = moveToNext ? step + 1 : step;
    const progress = calculateProgress(newStep, 6);

    // Construire la requÃªte SQL dynamiquement
    let sqlQuery = `
      UPDATE onboarding_sessions
      SET ${jsonField} = ?,
          current_step = ?,
          progress_percentage = ?,
          last_updated_at = ?
    `;
    
    const bindings = [JSON.stringify(data), Math.min(newStep, 6), progress, now];

    if (newStep > 6) {
      sqlQuery += `, status = 'completed', completed_at = ?`;
      bindings.push(now);
    }

    sqlQuery += ` WHERE id = ? AND tenant_id = ?`;
    bindings.push(sessionId, tenantId);

    await env.DB.prepare(sqlQuery).bind(...bindings).run();

    return {
      success: true,
      session: {
        id: sessionId,
        current_step: Math.min(newStep, 6),
        total_steps: 6,
        progress: progress,
        status: newStep > 6 ? 'completed' : 'in_progress'
      }
    };

  } catch (error) {
    console.error('Error updating onboarding step:', error);
    return {
      success: false,
      error: 'Erreur lors de la mise Ã  jour de l\'Ã©tape',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/:id/agents/auto-generate
 * GÃ©nÃ¨re automatiquement des agents selon l'industrie
 */
export async function autoGenerateAgents(request, env, sessionId, tenantId) {
  try {
    // RÃ©cupÃ©rer la session et les donnÃ©es business
    const session = await env.DB.prepare(`
      SELECT business_data FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session || !session.business_data) {
      return {
        success: false,
        error: 'DonnÃ©es business manquantes. ComplÃ©tez l\'Ã©tape 2 d\'abord.'
      };
    }

    const businessData = JSON.parse(session.business_data);
    const { industry, company_name } = businessData;

    if (!industry || !company_name) {
      return {
        success: false,
        error: 'Industrie et nom d\'entreprise requis'
      };
    }

    // GÃ©nÃ©rer les agents
    const agents = await generateDefaultAgents(env, tenantId, industry, company_name);

    // Initialiser les catÃ©gories de produits selon l'industrie
    const categoriesResult = await initializeProductCategories(env, tenantId, industry);
    console.log(`Categories initialized for tenant ${tenantId}:`, categoriesResult);

    // Mettre Ã  jour les analytics
    await env.DB.prepare(`
      UPDATE onboarding_analytics
      SET agents_auto_generated = 1,
          agents_created_count = ?
      WHERE session_id = ?
    `).bind(agents.length, sessionId).run();

    return {
      success: true,
      message: `${agents.length} agent(s) et ${categoriesResult.categoriesCreated} catÃ©gorie(s) crÃ©Ã©(s) avec succÃ¨s`,
      agents: agents,
      categories: categoriesResult.categories || []
    };

  } catch (error) {
    console.error('Error auto-generating agents:', error);
    return {
      success: false,
      error: 'Erreur lors de la gÃ©nÃ©ration automatique des agents',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/:id/twilio/auto-configure
 * Enregistre le numÃ©ro de tÃ©lÃ©phone du client pour identification via ForwardedFrom
 */
export async function autoConfigureTwilio(request, env, sessionId, tenantId) {
  try {
    // RÃ©cupÃ©rer la session et les donnÃ©es
    const session = await env.DB.prepare(`
      SELECT business_data FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session || !session.business_data) {
      return {
        success: false,
        error: 'DonnÃ©es business manquantes'
      };
    }

    const businessData = JSON.parse(session.business_data);
    const { phone, company_name } = businessData;

    if (!phone) {
      return {
        success: false,
        error: 'NumÃ©ro de tÃ©lÃ©phone manquant'
      };
    }

    // Normaliser le numÃ©ro (enlever espaces, etc.)
    const normalizedPhone = phone.replace(/\s+/g, '');

    // Mettre Ã  jour le tenant avec le numÃ©ro de tÃ©lÃ©phone pour identification
    await env.DB.prepare(`
      UPDATE tenants
      SET twilio_phone_number = ?,
          telephony_active = 1
      WHERE id = ?
    `).bind(
      normalizedPhone,
      tenantId
    ).run();

    // âœ¨ NOUVEAU : Ã‰crire DIRECTEMENT dans omni_phone_mappings pour le routing omnichannel
    const existingMapping = await env.DB.prepare(`
      SELECT id FROM omni_phone_mappings WHERE tenant_id = ?
    `).bind(tenantId).first();

    if (existingMapping) {
      // UPDATE
      await env.DB.prepare(`
        UPDATE omni_phone_mappings
        SET client_phone_number = ?,
            updated_at = datetime('now')
        WHERE tenant_id = ?
      `).bind(normalizedPhone, tenantId).run();
    } else {
      // CREATE
      const mappingId = `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      await env.DB.prepare(`
        INSERT INTO omni_phone_mappings (
          id, client_phone_number, tenant_id, created_at, updated_at
        ) VALUES (?, ?, ?, datetime('now'), datetime('now'))
      `).bind(mappingId, normalizedPhone, tenantId).run();
    }

    console.log(`Tenant ${tenantId} configured with phone ${normalizedPhone} + omni_phone_mappings`);

    // Mettre Ã  jour les analytics
    await env.DB.prepare(`
      UPDATE onboarding_analytics
      SET vapi_auto_configured = 1
      WHERE session_id = ?
    `).bind(sessionId).run();

    return {
      success: true,
      message: 'NumÃ©ro Twilio configurÃ© avec succÃ¨s',
      twilio: {
        phone_number: normalizedPhone,
        company_name: company_name,
        instructions: `Configurez un renvoi d'appel depuis ${normalizedPhone} vers ${env.TWILIO_PHONE_NUMBER || '+33939035760'}. Les appels seront automatiquement traitÃ©s par Sara.`
      }
    };

  } catch (error) {
    console.error('Error auto-configuring Twilio:', error);
    return {
      success: false,
      error: 'Erreur lors de la configuration Twilio',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/:id/kb/initialize
 * Initialise la Knowledge Base avec du contenu par dÃ©faut
 */
export async function initializeKB(request, env, sessionId, tenantId) {
  try {
    const body = await request.json();
    const { crawlUrl = null } = body;

    // RÃ©cupÃ©rer les donnÃ©es business
    const session = await env.DB.prepare(`
      SELECT business_data FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session || !session.business_data) {
      return {
        success: false,
        error: 'DonnÃ©es business manquantes'
      };
    }

    const businessData = JSON.parse(session.business_data);
    const { industry, company_name } = businessData;

    // Initialiser la KB avec les templates
    const { documentsCreated, faqsCreated } = await initializeKnowledgeBase(
      env, 
      tenantId, 
      industry, 
      company_name
    );

    // Si URL fournie, crÃ©er un job de crawl
    let crawlJobId = null;
    if (crawlUrl) {
      crawlJobId = generateId('crawl');
      await env.DB.prepare(`
        INSERT INTO knowledge_crawl_jobs (
          id, url, agent_id, status, max_pages,
          created_at
        ) VALUES (?, ?, 'system', 'pending', 50, ?)
      `).bind(
        crawlJobId,
        crawlUrl,
        new Date().toISOString()
      ).run();
    }

    // Mettre Ã  jour les analytics
    await env.DB.prepare(`
      UPDATE onboarding_analytics
      SET kb_auto_initialized = 1,
          documents_created_count = ?,
          crawl_launched = ?
      WHERE session_id = ?
    `).bind(
      documentsCreated,
      crawlUrl ? 1 : 0,
      sessionId
    ).run();

    return {
      success: true,
      message: 'Knowledge Base initialisÃ©e avec succÃ¨s',
      kb: {
        documents_created: documentsCreated,
        faqs_created: faqsCreated,
        crawl_job_id: crawlJobId,
        crawl_url: crawlUrl
      }
    };

  } catch (error) {
    console.error('Error initializing KB:', error);
    return {
      success: false,
      error: 'Erreur lors de l\'initialisation de la KB',
      details: error.message
    };
  }
}

/**
 * GET /api/v1/onboarding/:id/status
 * RÃ©cupÃ¨re le statut complet d'une session d'onboarding
 */
export async function getOnboardingStatus(request, env, sessionId, tenantId) {
  try {
    // RÃ©cupÃ©rer la session
    const session = await env.DB.prepare(`
      SELECT * FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session) {
      return {
        success: false,
        error: 'Session d\'onboarding non trouvÃ©e'
      };
    }

    // RÃ©cupÃ©rer les analytics
    const analytics = await env.DB.prepare(`
      SELECT * FROM onboarding_analytics
      WHERE session_id = ?
    `).bind(sessionId).first();

    // Construire la rÃ©ponse complÃ¨te
    return {
      success: true,
      session: {
        id: session.id,
        current_step: session.current_step,
        total_steps: session.total_steps,
        progress: session.progress_percentage,
        status: session.status,
        started_at: session.started_at,
        last_updated_at: session.last_updated_at,
        completed_at: session.completed_at
      },
      data: {
        business: session.business_data ? JSON.parse(session.business_data) : null,
        agents: session.agents_data ? JSON.parse(session.agents_data) : null,
        vapi: session.vapi_data ? JSON.parse(session.vapi_data) : null,
        kb: session.kb_data ? JSON.parse(session.kb_data) : null,
        completion: session.completion_data ? JSON.parse(session.completion_data) : null
      },
      completed: {
        business_info: !!session.business_data,
        agents_created: !!session.agents_data && analytics?.agents_auto_generated,
        vapi_configured: !!session.vapi_data && analytics?.vapi_auto_configured,
        kb_initialized: !!session.kb_data && analytics?.kb_auto_initialized,
        onboarding_completed: session.status === 'completed'
      },
      analytics: analytics ? {
        agents_count: analytics.agents_created_count,
        documents_count: analytics.documents_created_count,
        crawl_launched: analytics.crawl_launched
      } : null
    };

  } catch (error) {
    console.error('Error getting onboarding status:', error);
    return {
      success: false,
      error: 'Erreur lors de la rÃ©cupÃ©ration du statut',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/:id/complete
 * Marque l'onboarding comme terminÃ©
 */
export async function completeOnboarding(request, env, sessionId, tenantId) {
  try {
    const now = new Date().toISOString();

    // RÃ©cupÃ©rer les donnÃ©es du body (assistant_config, phone_config)
    let bodyData = {};
    try {
      bodyData = await request.json();
    } catch (e) {
      console.log('[Onboarding] No body data provided');
    }

    // Calculer la durÃ©e totale
    const session = await env.DB.prepare(`
      SELECT started_at FROM onboarding_sessions
      WHERE id = ? AND tenant_id = ? AND is_active = 1
    `).bind(sessionId, tenantId).first();

    if (!session) {
      return {
        success: false,
        error: 'Session non trouvÃ©e'
      };
    }

    const startTime = new Date(session.started_at);
    const endTime = new Date(now);
    const durationSeconds = Math.floor((endTime - startTime) / 1000);

    // ðŸ†• SYNCHRONISER LES DONNÃ‰ES VERS OMNICHANNEL
    console.log(`[Onboarding] Synchronizing data to omnichannel for tenant ${tenantId}`);
    const syncResult = await syncOnboardingToOmnichannel(env, sessionId, tenantId, bodyData);

    if (!syncResult.success) {
      console.error(`[Onboarding] Sync failed:`, syncResult.error);
      // On continue quand mÃªme mais on log l'erreur
    } else {
      console.log(`[Onboarding] Successfully synced to omnichannel`);
    }

    // Mettre Ã  jour la session
    await env.DB.prepare(`
      UPDATE onboarding_sessions
      SET status = 'completed',
          completed_at = ?,
          progress_percentage = 100,
          current_step = 6
      WHERE id = ? AND tenant_id = ?
    `).bind(now, sessionId, tenantId).run();

    // Mettre Ã  jour les analytics
    await env.DB.prepare(`
      UPDATE onboarding_analytics
      SET completed = 1,
          total_duration_seconds = ?
      WHERE session_id = ?
    `).bind(durationSeconds, sessionId).run();

    return {
      success: true,
      message: 'Onboarding terminÃ© avec succÃ¨s ! ðŸŽ‰',
      duration_seconds: durationSeconds,
      duration_minutes: Math.round(durationSeconds / 60),
      sync_status: syncResult.success ? 'synced' : 'partial'
    };

  } catch (error) {
    console.error('Error completing onboarding:', error);
    return {
      success: false,
      error: 'Erreur lors de la finalisation',
      details: error.message
    };
  }
}

/**
 * GET /api/v1/onboarding/templates
 * Liste les templates d'industrie disponibles
 */
export async function getOnboardingTemplates(request, env) {
  try {
    const templates = await env.DB.prepare(`
      SELECT id, industry, display_name, description, icon
      FROM onboarding_templates
      WHERE is_active = 1
      ORDER BY display_name ASC
    `).all();

    return {
      success: true,
      templates: templates.results
    };

  } catch (error) {
    console.error('Error getting templates:', error);
    return {
      success: false,
      error: 'Erreur lors de la rÃ©cupÃ©ration des templates',
      details: error.message
    };
  }
}

/**
 * GET /api/v1/onboarding/agent-types
 * RÃ©cupÃ¨re la liste des types d'agents disponibles
 */
export async function getAgentTypes(request, env) {
  try {
    // Import agent types depuis le module omnichannel
    const { AGENT_TYPES } = await import('../omnichannel/templates/agent-types.js');

    // Convertir l'objet en tableau avec les informations essentielles
    const agentTypesArray = Object.entries(AGENT_TYPES).map(([key, value]) => ({
      id: key,
      name: value.name,
      description: value.description,
      tools: value.tools || []
    }));

    return {
      success: true,
      agent_types: agentTypesArray
    };
  } catch (error) {
    console.error('Error fetching agent types:', error);
    return {
      success: false,
      error: 'Erreur lors de la rÃ©cupÃ©ration des types d\'agents',
      details: error.message
    };
  }
}

/**
 * ========================================================
 * ROUTER PRINCIPAL - GÃˆRE TOUTES LES ROUTES ONBOARDING
 * ========================================================
 */

/**
 * Handler principal pour toutes les routes Onboarding
 * AppelÃ© depuis index.js
 */
export async function handleOnboardingRoutes(request, env, ctx, corsHeaders) {
  const url = new URL(request.url);
  const path = url.pathname;
  const method = request.method;

  try {
    // GET /api/v1/onboarding/agent-types
    if (path === '/api/v1/onboarding/agent-types' && method === 'GET') {
      const result = await getAgentTypes(request, env);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // ðŸ†• POST /api/v1/onboarding/session - CrÃ©er nouvelle session
    if (path === '/api/v1/onboarding/session' && method === 'POST') {
      const tenantId = 'tenant_' + Date.now() + '_' + Math.random().toString(36).substring(7);
      const userId = 'user_' + Math.random().toString(36).substring(7);
      const now = new Date().toISOString();

      // CrÃ©er le tenant avec un API key temporaire et email unique
      const tempApiKey = 'tmp_' + Math.random().toString(36).substring(2, 15);
      const tempEmail = `temp_${tenantId}@onboarding.tmp`; // Email unique basÃ© sur tenantId
      await env.DB.prepare(`
        INSERT INTO tenants (
          id, name, email, api_key, created_at
        ) VALUES (?, ?, ?, ?, ?)
      `).bind(tenantId, 'Onboarding in progress', tempEmail, tempApiKey, now).run();

      const result = await startOnboarding(request, env, tenantId, userId);
      return new Response(JSON.stringify({
        success: true,
        session_id: result.session.id,
        tenant_id: tenantId
      }), {
        status: 201,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // ðŸ†• POST /api/v1/onboarding/session/:id/business - Sauvegarder business data
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/business$/) && method === 'POST') {
      try {
        const sessionId = path.split('/')[5];
        console.log('[Onboarding] POST /business for session:', sessionId);

        const body = await request.json();
        console.log('[Onboarding] Business data received:', JSON.stringify(body));

        // RÃ©cupÃ©rer le tenant_id de la session
        const session = await env.DB.prepare(`
          SELECT tenant_id FROM onboarding_sessions WHERE id = ?
        `).bind(sessionId).first();

        if (!session) {
          console.error('[Onboarding] Session not found:', sessionId);
          return new Response(JSON.stringify({
            success: false,
            error: 'Session not found'
          }), {
            status: 404,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        console.log('[Onboarding] Tenant ID:', session.tenant_id);

        // Mettre Ã  jour business_data dans onboarding_sessions
        const now = new Date().toISOString();
        await env.DB.prepare(`
          UPDATE onboarding_sessions
          SET business_data = ?,
              current_step = 2,
              progress_percentage = 33,
              last_updated_at = ?
          WHERE id = ?
        `).bind(JSON.stringify(body), now, sessionId).run();

        console.log('[Onboarding] Updated onboarding_sessions');

        // Mettre Ã  jour le tenant avec les infos business (utiliser les colonnes existantes: name, email)
        await env.DB.prepare(`
          UPDATE tenants
          SET name = ?,
              email = ?
          WHERE id = ?
        `).bind(
          body.company_name || 'Unknown',
          body.email || 'temp@onboarding.tmp',
          session.tenant_id
        ).run();

        console.log('[Onboarding] Updated tenants table');

        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        console.error('[Onboarding] Error saving business data:', error);
        return new Response(JSON.stringify({
          success: false,
          error: 'Internal server error',
          details: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // ðŸ†• POST /api/v1/onboarding/session/:id/vapi - Sauvegarder VAPI data + Ã©criture directe dans omni_agent_configs
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/vapi$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const body = await request.json();

      // RÃ©cupÃ©rer le tenant_id de la session
      const session = await env.DB.prepare(`
        SELECT tenant_id FROM onboarding_sessions WHERE id = ?
      `).bind(sessionId).first();

      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session non trouvÃ©e' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      const tenantId = session.tenant_id;

      // Mapper voice type vers voice_id ElevenLabs
      let voiceId = 'pNInz6obpgDQGcFmaJgB'; // Default female
      if (body.voice === 'male') {
        voiceId = 'onwK4e9ZLuTAKqWW03F9';
      } else if (body.voice === 'female') {
        voiceId = 'pNInz6obpgDQGcFmaJgB';
      }

      // âœ¨ NOUVEAU : Ã‰crire DIRECTEMENT dans omni_agent_configs
      const existing = await env.DB.prepare(`
        SELECT id FROM omni_agent_configs WHERE tenant_id = ?
      `).bind(tenantId).first();

      if (existing) {
        // UPDATE
        await env.DB.prepare(`
          UPDATE omni_agent_configs
          SET agent_name = ?,
              agent_type = ?,
              voice_id = ?,
              voice_language = 'fr-FR',
              updated_at = CURRENT_TIMESTAMP
          WHERE tenant_id = ?
        `).bind(
          body.assistant_name || 'Sara',
          body.agent_type || 'multi_purpose',
          voiceId,
          tenantId
        ).run();
      } else {
        // CREATE
        const configId = `cfg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        await env.DB.prepare(`
          INSERT INTO omni_agent_configs (
            id, tenant_id, agent_name, agent_type,
            voice_provider, voice_id, voice_language,
            greeting_message, created_at, updated_at
          ) VALUES (?, ?, ?, ?, 'elevenlabs', ?, 'fr-FR', ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `).bind(
          configId,
          tenantId,
          body.assistant_name || 'Sara',
          body.agent_type || 'multi_purpose',
          voiceId,
          `Bonjour, je suis ${body.assistant_name || 'Sara'}, votre assistant${body.voice === 'female' ? 'e' : ''} virtuel${body.voice === 'female' ? 'le' : ''}.`
        ).run();
      }

      const now = new Date().toISOString();

      // Toujours sauvegarder dans vapi_data pour tracking (optionnel, mais conservÃ© pour compatibilitÃ©)
      await env.DB.prepare(`
        UPDATE onboarding_sessions
        SET vapi_data = ?,
            current_step = 4,
            progress_percentage = 66,
            last_updated_at = ?
        WHERE id = ?
      `).bind(JSON.stringify(body), now, sessionId).run();

      return new Response(JSON.stringify({ success: true }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // ðŸ†• POST /api/v1/onboarding/session/:id/kb - Sauvegarder KB data
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/kb$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const body = await request.json();

      const now = new Date().toISOString();
      await env.DB.prepare(`
        UPDATE onboarding_sessions
        SET kb_data = ?,
            current_step = 5,
            progress_percentage = 83,
            last_updated_at = ?
        WHERE id = ?
      `).bind(JSON.stringify(body), now, sessionId).run();

      return new Response(JSON.stringify({ success: true }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // ðŸ†• POST /api/v1/onboarding/session/:id/complete - ComplÃ©ter onboarding
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/complete$/) && method === 'POST') {
      const sessionId = path.split('/')[5];

      // RÃ©cupÃ©rer le tenant_id de la session
      const session = await env.DB.prepare(`
        SELECT * FROM onboarding_sessions WHERE id = ?
      `).bind(sessionId).first();

      if (!session) {
        return new Response(JSON.stringify({
          success: false,
          error: 'Session not found'
        }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      const tenantId = session.tenant_id;
      const result = await completeOnboarding(request, env, sessionId, tenantId);

      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // GET /api/v1/onboarding/templates
    if (path === '/api/v1/onboarding/templates' && method === 'GET') {
      const result = await getOnboardingTemplates(request, env);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/start
    if (path === '/api/v1/onboarding/start' && method === 'POST') {
      const body = await request.json();
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      const userId = request.headers.get('x-user-id') || 'anonymous';
      
      const result = await startOnboarding(request, env, tenantId, userId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 201 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // PUT /api/v1/onboarding/:id/step
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/step$/) && method === 'PUT') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      
      const result = await updateOnboardingStep(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/:id/agents/auto-generate
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/agents\/auto-generate$/) && method === 'POST') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      
      const result = await autoGenerateAgents(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/:id/twilio/auto-configure
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/twilio\/auto-configure$/) && method === 'POST') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';

      const result = await autoConfigureTwilio(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/:id/kb/initialize
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/kb\/initialize$/) && method === 'POST') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      
      const result = await initializeKB(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // GET /api/v1/onboarding/:id/status
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/status$/) && method === 'GET') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      
      const result = await getOnboardingStatus(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/:id/complete
    if (path.match(/^\/api\/v1\/onboarding\/[^/]+\/complete$/) && method === 'POST') {
      const sessionId = path.split('/')[4];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      
      const result = await completeOnboarding(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Aucune route Onboarding ne correspond
    return null;

  } catch (error) {
    console.error('Error in handleOnboardingRoutes:', error);
    return new Response(JSON.stringify({
      success: false,
      error: 'Erreur serveur',
      details: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}
