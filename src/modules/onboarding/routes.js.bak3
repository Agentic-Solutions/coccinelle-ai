/**
 * =====================================================
 * COCCINELLE.AI - ONBOARDING ROUTES (ARCHITECTURE UNIFI√âE)
 * Version : 2.0.0
 * Date : 22 d√©cembre 2025
 * =====================================================
 *
 * PRINCIPE : Single Source of Truth
 *   - √âcriture DIRECTE dans les tables runtime (tenants, omni_agent_configs, etc.)
 *   - PAS de JSON temporaire dans onboarding_sessions
 *   - PAS de sync complexe
 *   - Transactions atomiques (rollback automatique si √©chec)
 *
 * =====================================================
 */

/**
 * G√©n√®re un ID unique
 */
function generateId(prefix) {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `${prefix}_${timestamp}_${random}`;
}

/**
 * POST /api/v1/onboarding/start
 * D√©marre une nouvelle session d'onboarding
 */
export async function startOnboarding(request, env, tenantId, userId) {
  try {
    const sessionId = generateId('onb');
    const now = new Date().toISOString();

    await env.DB.prepare(`
      INSERT INTO onboarding_sessions (
        id, tenant_id, user_id, current_step, status, started_at, last_updated_at, updated_at
      ) VALUES (?, ?, ?, 1, 'in_progress', ?, ?, ?)
    `).bind(sessionId, tenantId, userId, now, now, now).run();

    return {
      success: true,
      session_id: sessionId,
      tenant_id: tenantId
    };
  } catch (error) {
    console.error('[Onboarding] Error starting session:', error);
    return {
      success: false,
      error: 'Erreur lors du d√©marrage de l\'onboarding',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/session/:id/business
 * √âtape 2 : Informations business
 *
 * NOUVEAU : √âcrit directement dans `tenants` (pas de JSON temporaire)
 */
export async function saveBusinessInfo(request, env, sessionId, tenantId) {
  try {
    const { company_name, industry, email, phone } = await request.json();
    const now = new Date().toISOString();

    // Validation
    if (!company_name || !industry) {
      return {
        success: false,
        error: 'Nom d\'entreprise et secteur requis'
      };
    }

    // Transaction atomique : tout ou rien
    await env.DB.batch([
      // 1. Mettre √† jour le tenant avec les donn√©es business
      env.DB.prepare(`
        UPDATE tenants
        SET company_name = ?,
            sector = ?,
            phone = ?,
            updated_at = ?
        WHERE id = ?
      `).bind(company_name, industry, phone || null, now, tenantId),

      // 2. Mettre √† jour la progression (step 3)
      env.DB.prepare(`
        UPDATE onboarding_sessions
        SET current_step = 3,
            metadata = json_set(COALESCE(metadata, '{}'), '$.industry_template', ?),
            updated_at = ?
        WHERE id = ?
      `).bind(industry, now, sessionId)
    ]);

    console.log(`[Onboarding] Business info saved for tenant ${tenantId}`);

    return {
      success: true,
      message: 'Informations business enregistr√©es',
      next_step: 3
    };
  } catch (error) {
    console.error('[Onboarding] Error saving business info:', error);
    return {
      success: false,
      error: 'Erreur lors de la sauvegarde',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/session/:id/agents/auto-generate
 * √âtape 3 : G√©n√©ration automatique d'agents
 *
 * INCHANG√â : G√©n√®re des agents selon l'industrie
 */
export async function autoGenerateAgents(request, env, sessionId, tenantId) {
  try {
    const session = await env.DB.prepare(`
      SELECT metadata FROM onboarding_sessions WHERE id = ?
    `).bind(sessionId).first();

    if (!session) {
      return { success: false, error: 'Session introuvable' };
    }

    const metadata = JSON.parse(session.metadata || '{}');
    const industry = metadata.industry_template || 'generic';

    // Templates d'agents par industrie
    const agentTemplates = {
      'real_estate': [
        { name: 'Agent Principal', specialties: 'Ventes, Visites' },
        { name: 'Assistant Location', specialties: 'Location, Gestion locative' }
      ],
      'generic': [
        { name: 'Agent Principal', specialties: 'G√©n√©ral' }
      ]
    };

    const templates = agentTemplates[industry] || agentTemplates['generic'];
    const now = new Date().toISOString();

    // Cr√©er les agents
    const statements = [];
    for (const template of templates) {
      const agentId = generateId('agent');
      const email = `${template.name.toLowerCase().replace(/\s+/g, '.')}@${tenantId}.local`;

      statements.push(
        env.DB.prepare(`
          INSERT INTO commercial_agents (
            id, tenant_id, first_name, last_name, email, specialties, is_active, created_at
          ) VALUES (?, ?, ?, '', ?, ?, 1, ?)
        `).bind(agentId, tenantId, template.name, email, template.specialties, now)
      );

      // Disponibilit√©s par d√©faut (Lun-Ven, 9h-18h)
      for (let day = 1; day <= 5; day++) {
        const slotId = generateId('slot');
        statements.push(
          env.DB.prepare(`
            INSERT INTO availability_slots (
              id, agent_id, day_of_week, start_time, end_time, is_available
            ) VALUES (?, ?, ?, '09:00', '18:00', 1)
          `).bind(slotId, agentId, day)
        );
      }
    }

    // Mettre √† jour la progression
    statements.push(
      env.DB.prepare(`
        UPDATE onboarding_sessions
        SET current_step = 4, last_updated_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(now, sessionId)
    );

    await env.DB.batch(statements);

    console.log(`[Onboarding] ${templates.length} agents created for tenant ${tenantId}`);

    return {
      success: true,
      agents_created: templates.length,
      next_step: 4
    };
  } catch (error) {
    console.error('[Onboarding] Error generating agents:', error);
    return {
      success: false,
      error: 'Erreur lors de la g√©n√©ration des agents',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/session/:id/assistant
 * √âtape 4 : Configuration de l'assistant vocal
 *
 * NOUVEAU : √âcrit directement dans `omni_agent_configs` et `omni_phone_mappings`
 *           (pas de JSON temporaire, pas de sync)
 */
export async function saveAssistantConfig(request, env, sessionId, tenantId) {
  try {
    const {
      agent_type,
      agent_name,
      voice,
      enable_appointments,
      enable_products
    } = await request.json();

    // Validation
    if (!agent_type || !agent_name) {
      return {
        success: false,
        error: 'Type d\'agent et nom requis'
      };
    }

    // Mapper voice ‚Üí voice_id ElevenLabs
    const voiceId = voice === 'male'
      ? 'onwK4e9ZLuTAKqWW03F9'  // Voix masculine
      : 'pNInz6obpgDQGcFmaJgB';  // Voix f√©minine

    // R√©cup√©rer le t√©l√©phone du tenant
    const tenant = await env.DB.prepare(`
      SELECT phone, company_name FROM tenants WHERE id = ?
    `).bind(tenantId).first();

    if (!tenant) {
      return { success: false, error: 'Tenant introuvable' };
    }

    const now = new Date().toISOString();
    const configId = generateId('agent');
    const mappingId = generateId('mapping');

    // G√©n√©rer le greeting message
    const greeting = `Bonjour, je suis ${agent_name}, votre assistant${voice === 'female' ? 'e' : ''} virtuel${voice === 'female' ? 'le' : ''} chez ${tenant.company_name || 'notre entreprise'}. Comment puis-je vous aider ?`;

    // Transaction atomique
    const statements = [
      // 1. Cr√©er/mettre √† jour la config agent
      env.DB.prepare(`
        INSERT INTO omni_agent_configs (
          id, tenant_id, agent_type, agent_name,
          voice_provider, voice_id, voice_language,
          greeting_message,
          enable_appointments, enable_products,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, 'elevenlabs', ?, 'fr-FR', ?, ?, ?, ?, ?)
        ON CONFLICT(tenant_id) DO UPDATE SET
          agent_type = excluded.agent_type,
          agent_name = excluded.agent_name,
          voice_id = excluded.voice_id,
          greeting_message = excluded.greeting_message,
          enable_appointments = excluded.enable_appointments,
          enable_products = excluded.enable_products,
          updated_at = excluded.updated_at
      `).bind(
        configId, tenantId, agent_type, agent_name,
        voiceId, greeting,
        enable_appointments ? 1 : 0,
        enable_products ? 1 : 0,
        now, now
      )
    ];

    // 2. Cr√©er le phone mapping si t√©l√©phone disponible
    if (tenant.phone) {
      statements.push(
        env.DB.prepare(`
          INSERT INTO omni_phone_mappings (
            id, phone_number, tenant_id, is_active, created_at, updated_at
          ) VALUES (?, ?, ?, 1, ?, ?)
          ON CONFLICT(phone_number) DO UPDATE SET
            tenant_id = excluded.tenant_id,
            updated_at = excluded.updated_at
        `).bind(mappingId, tenant.phone, tenantId, now, now)
      );
    }

    // 3. Mettre √† jour la progression
    statements.push(
      env.DB.prepare(`
        UPDATE onboarding_sessions
        SET current_step = 5, last_updated_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(now, sessionId)
    );

    await env.DB.batch(statements);

    console.log(`[Onboarding] Assistant config saved for tenant ${tenantId}: ${agent_name} (${voice})`);

    return {
      success: true,
      message: 'Assistant configur√©',
      config: {
        agent_name,
        agent_type,
        voice,
        phone_mapped: !!tenant.phone
      },
      next_step: 5
    };
  } catch (error) {
    console.error('[Onboarding] Error saving assistant config:', error);
    return {
      success: false,
      error: 'Erreur lors de la configuration de l\'assistant',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/session/:id/knowledge
 * √âtape 5 : Initialisation de la base de connaissances
 *
 * INCHANG√â : √âcrit directement dans `knowledge_documents`
 */
export async function initializeKnowledgeBase(request, env, sessionId, tenantId) {
  try {
    const { documents } = await request.json();

    if (!documents || documents.length === 0) {
      // Optionnel : skip si pas de documents
      const now = new Date().toISOString();
      await env.DB.prepare(`
        UPDATE onboarding_sessions
        SET current_step = 6, last_updated_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(now, sessionId).run();

      return {
        success: true,
        message: '√âtape knowledge base ignor√©e',
        next_step: 6
      };
    }

    const now = new Date().toISOString();
    const statements = [];

    for (const doc of documents) {
      const docId = generateId('doc');
      statements.push(
        env.DB.prepare(`
          INSERT INTO knowledge_documents (
            id, tenant_id, title, source_type, source_url, content, status, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, 'active', ?, ?)
        `).bind(
          docId, tenantId,
          doc.title, doc.source_type, doc.source_url || null,
          doc.content, now, now
        )
      );
    }

    // Mettre √† jour la progression
    statements.push(
      env.DB.prepare(`
        UPDATE onboarding_sessions
        SET current_step = 6, last_updated_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(now, sessionId)
    );

    await env.DB.batch(statements);

    console.log(`[Onboarding] ${documents.length} KB documents created for tenant ${tenantId}`);

    return {
      success: true,
      documents_created: documents.length,
      next_step: 6
    };
  } catch (error) {
    console.error('[Onboarding] Error initializing KB:', error);
    return {
      success: false,
      error: 'Erreur lors de l\'initialisation de la knowledge base',
      details: error.message
    };
  }
}

/**
 * POST /api/v1/onboarding/session/:id/complete
 * √âtape 6 : Finalisation de l'onboarding
 *
 * NOUVEAU : Pas de sync, juste marquer comme compl√©t√©
 */
export async function completeOnboarding(request, env, sessionId, tenantId) {
  try {
    const now = new Date().toISOString();

    // Calculer la dur√©e
    const session = await env.DB.prepare(`
      SELECT started_at FROM onboarding_sessions WHERE id = ?
    `).bind(sessionId).first();

    const startTime = new Date(session.started_at);
    const endTime = new Date();
    const durationSeconds = Math.floor((endTime - startTime) / 1000);

    // Transaction atomique
    await env.DB.batch([
      // 1. Marquer le tenant comme onboard√©
      env.DB.prepare(`
        UPDATE tenants
        SET onboarding_completed = 1, updated_at = ?
        WHERE id = ?
      `).bind(now, tenantId),

      // 2. Marquer la session comme compl√©t√©e
      env.DB.prepare(`
        UPDATE onboarding_sessions
        SET status = 'completed',
            completed_at = ?,
            current_step = 6,
            updated_at = ?
        WHERE id = ?
      `).bind(now, now, sessionId)
    ]);

    // Analytics (optionnel, non bloquant)
    try {
      await env.DB.prepare(`
        INSERT INTO analytics_events (id, tenant_id, event_type, event_data, created_at)
        VALUES (?, ?, 'onboarding_completed', ?, ?)
      `).bind(
        generateId('event'),
        tenantId,
        JSON.stringify({ duration_seconds: durationSeconds }),
        now
      ).run();
    } catch (e) {
      console.error('[Onboarding] Analytics error (non-blocking):', e);
    }

    console.log(`[Onboarding] Completed for tenant ${tenantId} (${durationSeconds}s)`);

    return {
      success: true,
      message: 'Onboarding termin√© avec succ√®s ! üéâ',
      duration_seconds: durationSeconds,
      duration_minutes: Math.round(durationSeconds / 60)
    };
  } catch (error) {
    console.error('[Onboarding] Error completing onboarding:', error);
    return {
      success: false,
      error: 'Erreur lors de la finalisation',
      details: error.message
    };
  }
}

/**
 * GET /api/v1/onboarding/session/:id/status
 * R√©cup√®re le statut de la session
 */
export async function getOnboardingStatus(request, env, sessionId, tenantId) {
  try {
    const session = await env.DB.prepare(`
      SELECT * FROM onboarding_sessions WHERE id = ? AND tenant_id = ?
    `).bind(sessionId, tenantId).first();

    if (!session) {
      return {
        success: false,
        error: 'Session introuvable'
      };
    }

    return {
      success: true,
      session: {
        id: session.id,
        current_step: session.current_step,
        status: session.status,
        started_at: session.started_at,
        completed_at: session.completed_at
      }
    };
  } catch (error) {
    console.error('[Onboarding] Error getting status:', error);
    return {
      success: false,
      error: 'Erreur lors de la r√©cup√©ration du statut',
      details: error.message
    };
  }
}

/**
 * GET /api/v1/onboarding/agent-types
 * Liste les types d'agents disponibles
 */
export async function getAgentTypes(request, env) {
  try {
    // Types d'agents statiques (pas de DB)
    const agentTypes = [
      {
        id: 'real_estate_reception',
        name: 'R√©ception d\'appels immobiliers',
        description: 'Accueille les appels entrants, recherche des biens et prend des rendez-vous',
        tools: ['appointment_booking', 'property_search', 'crm_sync']
      },
      {
        id: 'appointment_booking',
        name: 'Prise de rendez-vous g√©n√©rique',
        description: 'Prend des rendez-vous pour tout type de service',
        tools: ['appointment_booking', 'calendar_sync']
      },
      {
        id: 'customer_support',
        name: 'Support client',
        description: 'R√©pond aux questions fr√©quentes et traite les demandes',
        tools: ['knowledge_base', 'ticket_creation']
      },
      {
        id: 'multi_purpose',
        name: 'Agent multi-usage',
        description: 'Agent polyvalent adaptable √† diff√©rents besoins',
        tools: ['appointment_booking', 'knowledge_base', 'crm_sync']
      }
    ];

    return {
      success: true,
      agent_types: agentTypes
    };
  } catch (error) {
    console.error('[Onboarding] Error getting agent types:', error);
    return {
      success: false,
      error: 'Erreur lors de la r√©cup√©ration des types d\'agents',
      details: error.message
    };
  }
}

/**
 * Router principal pour les routes d'onboarding
 */
export async function handleOnboardingRoutes(request, env, path, method) {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, x-tenant-id'
  };

  try {
    // POST /api/v1/onboarding/start
    if (path === '/api/v1/onboarding/start' && method === 'POST') {
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      const userId = request.headers.get('x-user-id') || 'anonymous';
      const result = await startOnboarding(request, env, tenantId, userId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 201 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/session/:id/business
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/business$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const session = await env.DB.prepare(`SELECT tenant_id FROM onboarding_sessions WHERE id = ?`).bind(sessionId).first();
      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      const result = await saveBusinessInfo(request, env, sessionId, session.tenant_id);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/session/:id/agents/auto-generate
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/agents\/auto-generate$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const session = await env.DB.prepare(`SELECT tenant_id FROM onboarding_sessions WHERE id = ?`).bind(sessionId).first();
      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      const result = await autoGenerateAgents(request, env, sessionId, session.tenant_id);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/session/:id/assistant
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/assistant$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const session = await env.DB.prepare(`SELECT tenant_id FROM onboarding_sessions WHERE id = ?`).bind(sessionId).first();
      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      const result = await saveAssistantConfig(request, env, sessionId, session.tenant_id);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/session/:id/knowledge
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/knowledge$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const session = await env.DB.prepare(`SELECT tenant_id FROM onboarding_sessions WHERE id = ?`).bind(sessionId).first();
      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      const result = await initializeKnowledgeBase(request, env, sessionId, session.tenant_id);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // POST /api/v1/onboarding/session/:id/complete
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/complete$/) && method === 'POST') {
      const sessionId = path.split('/')[5];
      const session = await env.DB.prepare(`SELECT tenant_id FROM onboarding_sessions WHERE id = ?`).bind(sessionId).first();
      if (!session) {
        return new Response(JSON.stringify({ success: false, error: 'Session not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      const result = await completeOnboarding(request, env, sessionId, session.tenant_id);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // GET /api/v1/onboarding/session/:id/status
    if (path.match(/^\/api\/v1\/onboarding\/session\/[^/]+\/status$/) && method === 'GET') {
      const sessionId = path.split('/')[5];
      const tenantId = request.headers.get('x-tenant-id') || 'default';
      const result = await getOnboardingStatus(request, env, sessionId, tenantId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // GET /api/v1/onboarding/agent-types
    if (path === '/api/v1/onboarding/agent-types' && method === 'GET') {
      const result = await getAgentTypes(request, env);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Route non trouv√©e
    return null;

  } catch (error) {
    console.error('Error in handleOnboardingRoutes:', error);
    return new Response(JSON.stringify({
      success: false,
      error: 'Erreur serveur',
      details: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}
