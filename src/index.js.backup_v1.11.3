import { Router } from 'itty-router';

const router = Router();

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, X-API-Key',
};

router.options('*', () => new Response(null, { headers: corsHeaders }));

async function authenticateApiKey(request, env) {
  const apiKey = request.headers.get('X-API-Key');
  if (!apiKey) return null;
  
  const tenant = await env.DB.prepare(
    'SELECT * FROM tenants WHERE api_key = ?'
  ).bind(apiKey).first();
  
  return tenant;
}

function generateToken() {
  return Array.from(crypto.getRandomValues(new Uint8Array(32)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

async function sendAppointmentNotifications(env, appointmentId, managementToken, firstName, datetime, phone, email) {
  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;
  
  const dateFormatted = new Date(datetime).toLocaleDateString('fr-FR', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZone: 'Europe/Paris'
  });

  if (phone && phone !== 'undefined' && env.TWILIO_ACCOUNT_SID && env.TWILIO_AUTH_TOKEN) {
    try {
      const smsBody = `Bonjour ${firstName}, votre rendez-vous est confirmé le ${dateFormatted}. Gérez-le ici : ${managementUrl}`;
      
      const twilioAuth = btoa(`${env.TWILIO_ACCOUNT_SID}:${env.TWILIO_AUTH_TOKEN}`);
      const smsResponse = await fetch(
        `https://api.twilio.com/2010-04-01/Accounts/${env.TWILIO_ACCOUNT_SID}/Messages.json`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Basic ${twilioAuth}`,
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            To: phone,
            From: env.TWILIO_PHONE_NUMBER,
            Body: smsBody,
          }),
        }
      );

      if (smsResponse.ok) {
        const smsData = await smsResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (tenant_id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, 'sms', ?, 'sent', ?, datetime('now'))
        `).bind('tenant_demo_001', appointmentId, phone, smsData.sid).run();
        
        console.log('✅ SMS envoyé:', smsData.sid);
      } else {
        const errorText = await smsResponse.text();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (tenant_id, appointment_id, type, recipient, status, error_message, sent_at)
          VALUES (?, ?, 'sms', ?, 'failed', ?, datetime('now'))
        `).bind('tenant_demo_001', appointmentId, phone, errorText).run();
        
        console.error('❌ Erreur SMS:', errorText);
      }
    } catch (error) {
      console.error('❌ Exception SMS:', error);
    }
  }

  if (email && email !== 'noemail@placeholder.com' && env.RESEND_API_KEY) {
    try {
      const emailResponse = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${env.RESEND_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          from: env.RESEND_FROM_EMAIL || 'onboarding@resend.dev',
          to: [email],
          subject: `Confirmation de rendez-vous - ${dateFormatted}`,
          html: `
            <h2>Bonjour ${firstName},</h2>
            <p>Votre rendez-vous est confirmé pour le <strong>${dateFormatted}</strong>.</p>
            <p><a href="${managementUrl}" style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Gérer mon rendez-vous</a></p>
            <p>À bientôt !</p>
          `,
        }),
      });

      if (emailResponse.ok) {
        const emailData = await emailResponse.json();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (tenant_id, appointment_id, type, recipient, status, provider_message_id, sent_at)
          VALUES (?, ?, 'email', ?, 'sent', ?, datetime('now'))
        `).bind('tenant_demo_001', appointmentId, email, emailData.id).run();
        
        console.log('✅ Email envoyé:', emailData.id);
      } else {
        const errorText = await emailResponse.text();
        await env.DB.prepare(`
          INSERT INTO appointment_notifications (tenant_id, appointment_id, type, recipient, status, error_message, sent_at)
          VALUES (?, ?, 'email', ?, 'failed', ?, datetime('now'))
        `).bind('tenant_demo_001', appointmentId, email, errorText).run();
        
        console.error('❌ Erreur Email:', errorText);
      }
    } catch (error) {
      console.error('❌ Exception Email:', error);
    }
  }
}

router.post('/webhooks/vapi/function-call', async (request, env, ctx) => {
  try {
    const payload = await request.json();
    const message = payload.message || payload;

    const tenant = await env.DB.prepare(
      'SELECT * FROM tenants WHERE vapi_assistant_id IS NOT NULL LIMIT 1'
    ).first();

    if (!tenant) {
      return new Response(JSON.stringify({ error: 'Tenant non trouvé' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    if (message.type === 'tool-calls' && message.toolCallList) {
      const results = [];

      for (const toolCall of message.toolCallList) {
        let result = null;

        if (toolCall.function.name === 'searchKnowledge') {
          result = await handleSearchKnowledge(toolCall.function.arguments, env, tenant);
        } else if (toolCall.function.name === 'checkAvailability') {
          result = handleCheckAvailabilitySimple(toolCall.function.arguments);
        } else if (toolCall.function.name === 'createAppointment') {
          result = await handleCreateAppointment(toolCall.function.arguments, env, tenant, message, ctx);
        }

        results.push({
          toolCallId: toolCall.id,
          result: result
        });
      }

      return new Response(JSON.stringify({ results }), {
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    return new Response(JSON.stringify({ received: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (error) {
    console.error('Erreur webhook:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
});

async function handleSearchKnowledge(args, env, tenant) {
  const { query } = args;
  
  const results = await env.DB.prepare(`
    SELECT answer FROM knowledge_base
    WHERE type = 'qa'
    AND (question LIKE ? OR answer LIKE ?)
    AND tenant_id = ?
    LIMIT 2
  `).bind(`%${query}%`, `%${query}%`, tenant.id).all();
  
  if (results.results.length > 0) {
    return results.results.map(r => r.answer).join(' ');
  }
  
  return "Je n'ai pas d'information spécifique sur ce sujet.";
}

function handleCheckAvailabilitySimple(args) {
  const { date } = args;
  return `Pour le ${date}, j'ai : 9h00, 10h00, 14h00, 15h00. Lequel préférez-vous ?`;
}

async function handleCreateAppointment(args, env, tenant, message, ctx) {
  const { firstName, lastName, phone, email, datetime } = args;
  
  try {
    let prospect = await env.DB.prepare(`
      SELECT id FROM prospects WHERE phone = ? AND tenant_id = ?
    `).bind(phone, tenant.id).first();
    
    let prospectId;
    if (!prospect) {
      prospectId = `prospect_${Date.now()}`;
      await env.DB.prepare(`
        INSERT INTO prospects (id, tenant_id, first_name, last_name, phone, email, status)
        VALUES (?, ?, ?, ?, ?, ?, 'contacted')
      `).bind(prospectId, tenant.id, firstName, lastName, phone, email).run();
    } else {
      prospectId = prospect.id;
    }
    
    const agent = await env.DB.prepare(`
      SELECT id FROM agents WHERE tenant_id = ? LIMIT 1
    `).bind(tenant.id).first();
    
    if (!agent) {
      return "Erreur : aucun agent disponible.";
    }
    
    const appointmentId = `appt_${Date.now()}`;
    const managementToken = generateToken();
    
    await env.DB.prepare(`
      INSERT INTO appointments 
      (id, tenant_id, prospect_id, agent_id, type, scheduled_at, status, management_token)
      VALUES (?, ?, ?, ?, 'phone_call', ?, 'confirmed', ?)
    `).bind(appointmentId, tenant.id, prospectId, agent.id, datetime, managementToken).run();
    
    console.log('✅ RDV créé:', appointmentId);
    
    try {
      const vapiCallId = message.call?.id || `call_${Date.now()}`;
      const callDuration = message.call?.duration || 0;
      const callCost = message.call?.cost || '0.00';
      
      await env.DB.prepare(`
        INSERT INTO vapi_call_logs (
          id, tenant_id, call_id, phone_number,
          status, duration_seconds, cost_usd,
          prospect_id, prospect_name, prospect_email,
          appointment_created, appointment_id,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
      `).bind(
        `log_${Date.now()}`,
        tenant.id,
        vapiCallId,
        phone || '',
        'completed',
        callDuration,
        callCost,
        prospectId,
        `${firstName} ${lastName}`,
        email || '',
        1,
        appointmentId
      ).run();
      
      console.log('✅ Log créé');
    } catch (logError) {
      console.error('❌ Erreur logging:', logError);
    }
    
    const match = datetime.match(/T(\d{2}):(\d{2})/);
    const localTime = match ? `${match[1]}h${match[2]}` : 'l\'heure demandée';
    
    const dateMatch = datetime.match(/^(\d{4})-(\d{2})-(\d{2})/);
    const localDate = dateMatch ? `${dateMatch[3]}/${dateMatch[2]}` : 'la date';
    
    const confirmationMessage = `Parfait ${firstName} ! Rendez-vous confirmé le ${localDate} à ${localTime}. Vous recevrez une confirmation par SMS.`;
    
    ctx.waitUntil(
      sendAppointmentNotifications(
        env, 
        appointmentId, 
        managementToken,
        firstName,
        datetime, 
        phone, 
        email
      )
    );
    
    return confirmationMessage;
    
  } catch (error) {
    console.error('❌ Erreur:', error);
    return `Erreur : ${error.message}`;
  }
}

router.get('/rdv/:token', async (request, env) => {
  const { token } = request.params;
  
  const appointment = await env.DB.prepare(`
    SELECT a.*, 
      COALESCE(p.first_name || ' ' || p.last_name, '') as prospect_name,
      p.phone as prospect_phone,
      ag.name as agent_name
    FROM appointments a
    LEFT JOIN prospects p ON a.prospect_id = p.id
    LEFT JOIN agents ag ON a.agent_id = ag.id
    WHERE a.management_token = ?
  `).bind(token).first();

  if (!appointment) {
    return new Response('Rendez-vous non trouvé', { 
      status: 404,
      headers: { 'Content-Type': 'text/html; charset=utf-8' }
    });
  }

  const html = `
    <!DOCTYPE html>
    <html lang="fr">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Gestion de rendez-vous</title>
      <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: white; border-radius: 8px; padding: 32px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        h1 { font-size: 24px; margin-bottom: 24px; color: #1a1a1a; }
        .info { margin-bottom: 16px; padding: 12px; background: #f9f9f9; border-radius: 6px; }
        .label { font-size: 12px; color: #666; text-transform: uppercase; margin-bottom: 4px; }
        .value { font-size: 16px; color: #1a1a1a; }
        .status { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 14px; margin-top: 8px; }
        .status.confirmed { background: #d4edda; color: #155724; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>Votre rendez-vous</h1>
        <div class="info">
          <div class="label">Date et heure</div>
          <div class="value">${new Date(appointment.scheduled_at).toLocaleString('fr-FR', { timeZone: 'Europe/Paris' })}</div>
        </div>
        <div class="info">
          <div class="label">Agent</div>
          <div class="value">${appointment.agent_name || 'Non assigné'}</div>
        </div>
        <div class="info">
          <div class="label">Statut</div>
          <div class="status confirmed">${appointment.status === 'confirmed' ? 'Confirmé' : appointment.status}</div>
        </div>
      </div>
    </body>
    </html>
  `;

  return new Response(html, {
    headers: { 'Content-Type': 'text/html; charset=utf-8' }
  });
});

router.get('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const prospects = await env.DB.prepare(
    'SELECT * FROM prospects WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify(prospects.results), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.post('/api/v1/prospects', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const { name, email, phone, source, notes } = await request.json();
  const prospectId = `prospect_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO prospects (id, tenant_id, name, email, phone, source, notes, status)
    VALUES (?, ?, ?, ?, ?, ?, ?, 'new')
  `).bind(prospectId, tenant.id, name, email, phone, source || 'api', notes || '').run();

  return new Response(JSON.stringify({ success: true, id: prospectId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/agents', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const agents = await env.DB.prepare(
    'SELECT * FROM agents WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ success: true, agents: agents.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/appointments', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const appointments = await env.DB.prepare(`
    SELECT a.*, 
      COALESCE(p.first_name || ' ' || p.last_name, '') as prospect_name,
      ag.name as agent_name
    FROM appointments a
    LEFT JOIN prospects p ON a.prospect_id = p.id
    LEFT JOIN agents ag ON a.agent_id = ag.id
    WHERE a.tenant_id = ?
    ORDER BY a.scheduled_at DESC
  `).bind(tenant.id).all();

  return new Response(JSON.stringify({ success: true, appointments: appointments.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.post('/api/v1/appointments', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const { prospect_id, agent_id, property_id, service_id, type, scheduled_at, notes } = await request.json();
  
  const appointmentId = `appt_${Date.now()}`;
  const managementToken = generateToken();
  const managementUrl = `https://coccinelle-api.youssef-amrouche.workers.dev/rdv/${managementToken}`;

  await env.DB.prepare(`
    INSERT INTO appointments 
    (id, tenant_id, prospect_id, agent_id, property_id, service_id, type, scheduled_at, status, management_token, notes)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'scheduled', ?, ?)
  `).bind(
    appointmentId, 
    tenant.id, 
    prospect_id, 
    agent_id, 
    property_id || null, 
    service_id || null, 
    type, 
    scheduled_at, 
    managementToken, 
    notes || ''
  ).run();

  return new Response(JSON.stringify({ 
    success: true, 
    id: appointmentId,
    management_url: managementUrl
  }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/services', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const services = await env.DB.prepare(
    'SELECT * FROM services WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ success: true, services: services.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/knowledge-base', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const kb = await env.DB.prepare(
    'SELECT * FROM knowledge_base WHERE tenant_id = ?'
  ).bind(tenant.id).all();

  return new Response(JSON.stringify({ success: true, knowledge: kb.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.post('/api/v1/knowledge-base', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const { type, category, question, answer, document_url, metadata } = await request.json();
  const kbId = `kb_${Date.now()}`;

  await env.DB.prepare(`
    INSERT INTO knowledge_base (id, tenant_id, type, category, question, answer, document_url, metadata)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(kbId, tenant.id, type, category || null, question || null, answer || null, document_url || null, metadata || null).run();

  return new Response(JSON.stringify({ success: true, id: kbId }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/vapi/calls', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const { status, prospect_id, date_from, date_to } = Object.fromEntries(new URL(request.url).searchParams);
  
  let query = 'SELECT * FROM vapi_call_logs WHERE tenant_id = ?';
  const params = [tenant.id];
  
  if (status) {
    query += ' AND status = ?';
    params.push(status);
  }
  
  if (prospect_id) {
    query += ' AND prospect_id = ?';
    params.push(prospect_id);
  }
  
  if (date_from) {
    query += ' AND created_at >= ?';
    params.push(date_from);
  }
  
  if (date_to) {
    query += ' AND created_at <= ?';
    params.push(date_to);
  }
  
  query += ' ORDER BY created_at DESC LIMIT 50';
  
  const calls = await env.DB.prepare(query).bind(...params).all();

  return new Response(JSON.stringify({ success: true, calls: calls.results }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/vapi/calls/:callId', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const { callId } = request.params;
  
  const call = await env.DB.prepare(
    'SELECT * FROM vapi_call_logs WHERE id = ? AND tenant_id = ?'
  ).bind(callId, tenant.id).first();

  if (!call) {
    return new Response(JSON.stringify({ success: false, error: 'Appel non trouvé' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  return new Response(JSON.stringify({ success: true, call }), {
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

router.get('/api/v1/vapi/stats', async (request, env) => {
  const tenant = await authenticateApiKey(request, env);
  if (tenant instanceof Response) return tenant;

  const stats = await getVapiStats(env, tenant.id);

  return new Response(JSON.stringify({
    success: true,
    stats: stats
  }), {
    status: 200,
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
});

async function getVapiStats(env, tenantId) {
  const stats = await env.DB.prepare(`
    SELECT 
      COUNT(*) as total_calls,
      SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_calls,
      SUM(appointment_created) as appointments_created,
      ROUND(AVG(duration_seconds), 0) as avg_duration_seconds,
      ROUND(SUM(CAST(cost_usd AS REAL)), 2) as total_cost_usd,
      ROUND(AVG(CAST(sentiment_score AS REAL)), 2) as avg_sentiment
    FROM vapi_call_logs
    WHERE tenant_id = ?
  `).bind(tenantId).first();

  const conversionRate = stats.total_calls > 0 
    ? Math.round((stats.appointments_created / stats.total_calls) * 100) 
    : 0;

  return {
    total_calls: stats.total_calls || 0,
    completed_calls: stats.completed_calls || 0,
    appointments_created: stats.appointments_created || 0,
    conversion_rate: `${conversionRate}%`,
    avg_duration_seconds: stats.avg_duration_seconds || 0,
    total_cost_usd: (stats.total_cost_usd || 0).toFixed(2),
    avg_sentiment: (stats.avg_sentiment || 0).toFixed(2)
  };
}

router.all('*', () => new Response('Not Found', { status: 404 }));

export default {
  fetch: router.handle
};
