// ============================================================================
// COCCINELLE.AI - BACKEND API
// Version : 1.16.0
// Phase 5 : Search & RAG
// ============================================================================

import { processDocument } from './text-processing.js';
import { processDocumentEmbeddings, getEmbeddingsStatus } from './embeddings.js';
import { ragPipeline, hybridSearch, upsertToVectorize } from './search.js';

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;

    // CORS headers
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // ========================================
      // ROUTE PAR DÉFAUT
      // ========================================
      if (path === '/' || path === '') {
        return new Response(JSON.stringify({
          service: 'Coccinelle.ai API',
          version: '1.16.0',
          status: 'operational',
          phases: {
            phase1_kb_database: 'completed',
            phase2_web_crawler: 'completed',
            phase3_text_processing: 'completed',
            phase4_embeddings: 'completed',
            phase5_search_rag: 'in_progress'
          },
          endpoints: {
            knowledge: '/api/v1/knowledge/*',
            embeddings: '/api/v1/knowledge/documents/:id/embeddings',
            search: '/api/v1/knowledge/search',
            ask: '/api/v1/knowledge/ask'
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // KNOWLEDGE BASE - DOCUMENTS
      // ========================================

      // GET /api/v1/knowledge/documents - Liste tous les documents
      if (path === '/api/v1/knowledge/documents' && method === 'GET') {
        const documents = await env.DB.prepare(`
          SELECT 
            id, tenant_id, source_type, source_url, title,
            word_count, chunk_count, status, 
            crawled_at, indexed_at, created_at
          FROM knowledge_documents
          WHERE is_active = 1
          ORDER BY created_at DESC
        `).all();

        return new Response(JSON.stringify({
          success: true,
          count: documents.results.length,
          documents: documents.results
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // POST /api/v1/knowledge/documents/:id/process - Process document (chunking)
      if (path.match(/^\/api\/v1\/knowledge\/documents\/[^\/]+\/process$/) && method === 'POST') {
        const documentId = path.split('/')[5];

        console.log('[TEXT-PROCESSING] Starting processing for document:', documentId);

        ctx.waitUntil(
          processDocument(env.DB, documentId)
            .then(result => {
              console.log('[TEXT-PROCESSING] Processing completed:', result);
            })
            .catch(error => {
              console.error('[TEXT-PROCESSING] Processing failed:', error);
            })
        );

        return new Response(JSON.stringify({
          success: true,
          message: 'Document processing started',
          documentId
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // EMBEDDINGS (PHASE 4)
      // ========================================

      // POST /api/v1/knowledge/documents/:id/embeddings - Générer embeddings
      if (path.match(/^\/api\/v1\/knowledge\/documents\/[^\/]+\/embeddings$/) && method === 'POST') {
        const documentId = path.split('/')[5];

        console.log('[EMBEDDINGS-API] Starting embeddings generation for:', documentId);

        if (!env.OPENAI_API_KEY) {
          return new Response(JSON.stringify({
            success: false,
            error: 'OpenAI API key not configured'
          }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        ctx.waitUntil(
          processDocumentEmbeddings(env.DB, documentId, env.OPENAI_API_KEY)
            .then(result => {
              console.log('[EMBEDDINGS-API] Embeddings generation completed:', result);
            })
            .catch(error => {
              console.error('[EMBEDDINGS-API] Embeddings generation failed:', error);
            })
        );

        return new Response(JSON.stringify({
          success: true,
          message: 'Embeddings generation started',
          documentId,
          note: 'Processing in background - check status endpoint'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // GET /api/v1/knowledge/documents/:id/embeddings/status - Status embeddings
      if (path.match(/^\/api\/v1\/knowledge\/documents\/[^\/]+\/embeddings\/status$/) && method === 'GET') {
        const documentId = path.split('/')[5];

        console.log('[EMBEDDINGS-API] Checking embeddings status for:', documentId);

        const status = await getEmbeddingsStatus(env.DB, documentId);

        return new Response(JSON.stringify(status), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // SEARCH & RAG (PHASE 5) ✨ NOUVEAU
      // ========================================

      // POST /api/v1/knowledge/search - Recherche hybride
      if (path === '/api/v1/knowledge/search' && method === 'POST') {
        const data = await request.json();

        console.log('[SEARCH-API] Recherche hybride:', data.query);

        // Validation
        if (!data.query) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Missing required field: query'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        if (!env.OPENAI_API_KEY) {
          return new Response(JSON.stringify({
            success: false,
            error: 'OpenAI API key not configured'
          }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Recherche hybride
        const results = await hybridSearch({
          query: data.query,
          db: env.DB,
          vectorize: env.VECTORIZE,
          openaiApiKey: env.OPENAI_API_KEY,
          topK: data.topK || 10,
          tenantId: data.tenantId || null
        });

        return new Response(JSON.stringify(results), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // POST /api/v1/knowledge/ask - Question-réponse RAG
      if (path === '/api/v1/knowledge/ask' && method === 'POST') {
        const data = await request.json();

        console.log('[ASK-API] Question RAG:', data.question);

        // Validation
        if (!data.question) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Missing required field: question'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        if (!env.OPENAI_API_KEY || !env.ANTHROPIC_API_KEY) {
          return new Response(JSON.stringify({
            success: false,
            error: 'API keys not configured (OpenAI and Anthropic required)'
          }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Pipeline RAG complet
        const result = await ragPipeline({
          question: data.question,
          db: env.DB,
          vectorize: env.VECTORIZE,
          openaiApiKey: env.OPENAI_API_KEY,
          anthropicApiKey: env.ANTHROPIC_API_KEY,
          topK: data.topK || 5,
          tenantId: data.tenantId || null
        });

        return new Response(JSON.stringify(result), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // POST /api/v1/knowledge/sync-vectorize - Migration embeddings vers Vectorize
      if (path === '/api/v1/knowledge/sync-vectorize' && method === 'POST') {
        const data = await request.json();

        console.log('[SYNC-API] Sync Vectorize:', data.documentId || 'all');

        if (!env.OPENAI_API_KEY) {
          return new Response(JSON.stringify({
            success: false,
            error: 'OpenAI API key not configured'
          }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Récupérer chunks avec embeddings
        let query = `
          SELECT 
            kc.id,
            kc.document_id,
            kc.tenant_id,
            kc.chunk_index,
            kc.content
          FROM knowledge_chunks kc
          WHERE kc.vector_id IS NOT NULL
        `;

        const params = [];
        
        if (data.documentId) {
          query += ` AND kc.document_id = ?`;
          params.push(data.documentId);
        }

        query += ` ORDER BY kc.document_id, kc.chunk_index`;

        const chunks = await env.DB.prepare(query).bind(...params).all();

        if (!chunks.results || chunks.results.length === 0) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No chunks with embeddings found'
          }), {
            status: 404,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Générer embeddings pour chaque chunk et upsert
        console.log('[SYNC-API] Generating embeddings for chunks:', chunks.results.length);

        // Note: Pour cette version, on va juste valider la structure
        // La véritable migration se fera avec les embeddings déjà générés en Phase 4
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Sync will be implemented with existing embeddings',
          chunksFound: chunks.results.length,
          note: 'This endpoint prepares for vectorize migration'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // PROSPECTS
      // ========================================
      
      if (path === '/api/v1/prospects' && method === 'GET') {
        const prospects = await env.DB.prepare('SELECT * FROM prospects').all();
        return new Response(JSON.stringify(prospects.results), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      if (path === '/api/v1/prospects' && method === 'POST') {
        const data = await request.json();
        const id = crypto.randomUUID();
        
        await env.DB.prepare(`
          INSERT INTO prospects (id, nom, prenom, email, telephone, created_at)
          VALUES (?, ?, ?, ?, ?, datetime('now'))
        `).bind(id, data.nom, data.prenom, data.email, data.telephone).run();

        return new Response(JSON.stringify({ id, ...data }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // AGENTS
      // ========================================
      
      if (path === '/api/v1/agents' && method === 'GET') {
        const agents = await env.DB.prepare('SELECT * FROM agents').all();
        return new Response(JSON.stringify(agents.results), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      if (path.match(/^\/api\/v1\/agents\/[^\/]+\/availability$/) && method === 'GET') {
        const agentId = path.split('/')[4];
        const date = url.searchParams.get('date');
        
        const slots = await env.DB.prepare(`
          SELECT * FROM agent_availability 
          WHERE agent_id = ? AND date = ? AND is_available = 1
        `).bind(agentId, date).all();

        return new Response(JSON.stringify(slots.results), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // APPOINTMENTS
      // ========================================
      
      if (path === '/api/v1/appointments' && method === 'GET') {
        const appointments = await env.DB.prepare(`
          SELECT a.*, p.nom, p.prenom, p.email
          FROM appointments a
          JOIN prospects p ON a.prospect_id = p.id
          ORDER BY a.datetime_rdv DESC
        `).all();

        return new Response(JSON.stringify(appointments.results), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      if (path === '/api/v1/appointments' && method === 'POST') {
        const data = await request.json();
        const id = crypto.randomUUID();
        const token = crypto.randomUUID();
        
        await env.DB.prepare(`
          INSERT INTO appointments (
            id, prospect_id, agent_id, datetime_rdv, 
            statut, confirmation_token, created_at
          )
          VALUES (?, ?, ?, ?, 'pending', ?, datetime('now'))
        `).bind(
          id, 
          data.prospect_id, 
          data.agent_id, 
          data.datetime_rdv,
          token
        ).run();

        return new Response(JSON.stringify({ id, token, ...data }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // VAPI WEBHOOKS
      // ========================================
      
      if (path === '/webhooks/vapi/function-call' && method === 'POST') {
        const payload = await request.json();
        console.log('VAPI Function Call:', JSON.stringify(payload, null, 2));

        const functionName = payload.message?.functionCall?.name;
        const parameters = payload.message?.functionCall?.parameters;

        if (functionName === 'checkAvailability') {
          const slots = await env.DB.prepare(`
            SELECT time_slot FROM agent_availability 
            WHERE agent_id = ? AND date = ? AND is_available = 1
          `).bind(parameters.agentId, parameters.date).all();

          return new Response(JSON.stringify({
            results: [{
              slots: slots.results.map(s => s.time_slot)
            }]
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        if (functionName === 'bookAppointment') {
          const appointmentId = crypto.randomUUID();
          const token = crypto.randomUUID();
          
          await env.DB.prepare(`
            INSERT INTO appointments (
              id, prospect_id, agent_id, datetime_rdv,
              statut, confirmation_token, created_at
            )
            VALUES (?, ?, ?, ?, 'pending', ?, datetime('now'))
          `).bind(
            appointmentId,
            parameters.prospectId,
            parameters.agentId,
            `${parameters.date} ${parameters.time}`,
            token
          ).run();

          return new Response(JSON.stringify({
            results: [{
              appointmentId,
              confirmationToken: token,
              status: 'pending'
            }]
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        return new Response(JSON.stringify({
          results: [{ error: 'Unknown function' }]
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // RDV CONFIRMATION
      // ========================================
      
      if (path.match(/^\/rdv\/[^\/]+$/) && method === 'GET') {
        const token = path.split('/')[2];
        
        const appointment = await env.DB.prepare(`
          SELECT a.*, p.nom, p.prenom, p.email, ag.nom as agent_nom
          FROM appointments a
          JOIN prospects p ON a.prospect_id = p.id
          JOIN agents ag ON a.agent_id = ag.id
          WHERE a.confirmation_token = ?
        `).bind(token).first();

        if (!appointment) {
          return new Response('Rendez-vous non trouvé', { status: 404 });
        }

        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>Confirmation RDV</title>
            <style>
              body { font-family: Arial; max-width: 600px; margin: 50px auto; padding: 20px; }
              .btn { padding: 10px 20px; margin: 10px; cursor: pointer; }
              .confirm { background: green; color: white; }
              .cancel { background: red; color: white; }
            </style>
          </head>
          <body>
            <h1>Confirmation de Rendez-vous</h1>
            <p>Bonjour ${appointment.prenom} ${appointment.nom},</p>
            <p>Votre rendez-vous avec ${appointment.agent_nom}</p>
            <p>Date: ${appointment.datetime_rdv}</p>
            <button class="btn confirm" onclick="confirm()">Confirmer</button>
            <button class="btn cancel" onclick="cancel()">Annuler</button>
            <script>
              function confirm() {
                fetch('/rdv/${token}', { 
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ action: 'confirm' })
                }).then(() => alert('Rendez-vous confirmé!'));
              }
              function cancel() {
                fetch('/rdv/${token}', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ action: 'cancel' })
                }).then(() => alert('Rendez-vous annulé'));
              }
            </script>
          </body>
          </html>
        `;

        return new Response(html, {
          headers: { 'Content-Type': 'text/html' }
        });
      }

      if (path.match(/^\/rdv\/[^\/]+$/) && method === 'POST') {
        const token = path.split('/')[2];
        const data = await request.json();
        
        const newStatus = data.action === 'confirm' ? 'confirmed' : 'cancelled';
        
        await env.DB.prepare(`
          UPDATE appointments 
          SET statut = ?
          WHERE confirmation_token = ?
        `).bind(newStatus, token).run();

        return new Response(JSON.stringify({ status: newStatus }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // ========================================
      // 404
      // ========================================
      
      return new Response(JSON.stringify({
        error: 'Route non trouvée',
        path,
        method
      }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('Erreur serveur:', error);
      return new Response(JSON.stringify({
        error: 'Erreur serveur',
        message: error.message
      }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
};
